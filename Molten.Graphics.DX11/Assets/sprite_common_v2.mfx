struct SpriteVertex
{
	float2 pos;
	float2 size;
	float2 origin;
	float4 uv;
	float rotation;
	float arraySlice;
	float4 col;
    float4 data;
};

struct VS_GS
{
    uint vID        : VERTEXID;
};

struct PS_IN
{
	float4 pos      : SV_POSITION;
	float3 uv       : TEXCOORD0;
    float2 uvLocal  : TEXCOORD1;      //UV Relative to top left of sprite (0 - 1 range)
    uint id         : VERTEXID;
};

StructuredBuffer<SpriteVertex> spriteData : register(t0);

Texture2DArray mapDiffuse : register(t1);
Texture2DMSArray<float4> mapDiffuseMS : register(t2);
SamplerState diffuseSampler;

float4x4 wvp;
float2 textureSize;
uint sampleCount = 8;
uint vertexOffset = 0;

static float degToRad360 = 6.28319;

VS_GS VS(uint vID : SV_VertexID)
{
    VS_GS output;

    output.vID = vID;
	return output;
}

const static float2 spriteCorners[4] = {
	float2(0,-1),
	float2(0, 0),
	float2(1,-1),
	float2(1,0),
};

// 0 = left, 1 = top, 2 = right, 3 = bottom
const static int2 uvTable[4] = {
	int2(0,3), // Bottom left
	int2(0,1), // Top left
	int2(2,3), // Bottom right
	int2(2,1), // Top right
};

float4 baseUV = float4(0,0,1,1);
static const float2 QUAD_CENTER_UV = float2(0.5,0.5);
static const float PI = 3.14159265;

float2x2 GetRotation(float angle)
{
	// Compute a 2x2 rotation matrix.
	float c = cos(angle);
	float s = sin(angle);

	return float2x2(c, -s, s, c);
}

[maxvertexcount(4)]
void GS(point VS_GS input[1], uint pID : SV_PrimitiveID, inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
    v.id = vertexOffset + input[0].vID;
    SpriteVertex sv = spriteData[v.id];
    float4 uv = sv.uv;

    uv.xz /= textureSize.x; // scale left (x) and right(z) to 0 - 1.0 range.
	uv.yw /= textureSize.y; // Scale top (y) and bottom(w) to 0 - 1.0 range.

	float2x2 rot = GetRotation(sv.rotation);
	float2 origin = float2(sv.origin.x, -sv.origin.y);  // Invert y origin
	float2 pos = float2(sv.pos.x, -sv.pos.y);           // Invert y axis
	float2 p;

	[unroll]
	for (int i = 0; i < 4; i++)
	{
		p = mul(sv.size.xy * (spriteCorners[i] - origin), rot);
		p += pos;
		v.pos = float4(p, 0, 1);
		v.pos = mul(v.pos, wvp);
		v.uv.x = uv[uvTable[i].x];
		v.uv.y = uv[uvTable[i].y];
		v.uv.z = sv.arraySlice;
        v.uvLocal.x = baseUV[uvTable[i].x];
        v.uvLocal.y = baseUV[uvTable[i].y];
		spriteStream.Append(v);
	}
}

float4 PS( PS_IN input ) : SV_Target
{
	float4 col = mapDiffuse.Sample(diffuseSampler, input.uv);
	return col * spriteData[input.id].col;
}

float4 PS_NoTexture(PS_IN input) : SV_Target
{
	return spriteData[input.id].col;
}

float4 PS_Circle(PS_IN input) : SV_Target
{   
    // Data.y (D2) = Angle range (Radians)

    float2 d = input.uvLocal - 0.5;
    float rad = -PI + spriteData[input.id].data.y;
    if(rad < atan2(d.y, d.x))
        discard;

    float dist = length(distance(input.uvLocal, QUAD_CENTER_UV)); // Distance from quad center (0.5, 0.5)
    float step = 1 - smoothstep(0.97, 1, (dist / 0.5));
   	float4 sampCol = mapDiffuse.Sample(diffuseSampler, input.uv);
    float4 finalCol = sampCol * spriteData[input.id].col;
	return float4(finalCol.rgb, finalCol.a * step);
}

float4 PS_Circle_NoTex(PS_IN input) : SV_Target
{   
    // Data.y (D2) = Angle range (Radians)

    float4 col = spriteData[input.id].col;

    float2 d = input.uvLocal - 0.5;
    float rad = -PI + spriteData[input.id].data.y;
    if(rad < atan2(d.y, d.x))
        discard;

    float dist = length(distance(input.uvLocal, QUAD_CENTER_UV)); // Distance from quad center (0.5, 0.5)
    float step = 1 - smoothstep(0.97, 1, (dist / 0.5));
	return float4(col.rgb, col.a * step);
}

float4 PS_Circle_Outline(PS_IN input) : SV_Target
{       
    // Data.x (D1) = Thickness
    // Data.y (D2) = Angle range (Radians)

    float4 col = spriteData[input.id].col;

    float2 d = input.uvLocal - 0.5;
    float rad = -PI + spriteData[input.id].data.y;
    if(rad < atan2(d.y, d.x))
        discard;

    float4 thickness = spriteData[input.id].data.x;

    float dist = length(distance(input.uvLocal, QUAD_CENTER_UV)); // Distance from quad center (0.5, 0.5)

    float step = 1 - smoothstep(0.97 - thickness, 1 - thickness, (dist / 0.5));
    float stepBorder = smoothstep(0.97, 1, (dist / 0.5));

    float4 c = float4(col.rgb, col.a * step) + float4(col.rgb, col.a * stepBorder);
	return float4(c.rgb, 1.0 - c.a);
}


float distanceToLine(float2 p1, float2 p2, float2 pnt) {
    float a = p1.y-p2.y;
    float b = p2.x-p1.x;
    return abs(a*pnt.x+b*pnt.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);
}

float4 PS_Line(PS_IN input) : SV_Target
{
    // Data.x (D1) = Thickness
   

    float dist = distanceToLine(float2(0,0.5), float2(1,0.5), input.uvLocal);
    float step = 1.0 - smoothstep(0, spriteData[input.id].data.x, dist);

    float4 col1 = spriteData[input.id].col;
    float4 col2 = spriteData[input.id].uv;
    float4 col = lerp(col1, col2, input.uvLocal.x);

    return float4(col.rgb, col.a * step);
}