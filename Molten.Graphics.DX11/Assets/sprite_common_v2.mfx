struct SpriteVertex
{
	float2 pos;
	float2 size;
	float2 origin;
	float4 uv;
	float rotation;
	float arraySlice;
	float4 col;
};

struct VS_GS
{
    uint vID : VERTEXID;
};

struct PS_IN
{
	float4 pos : SV_POSITION;
	float4 col : COLOR;
	float3 uv : TEXCOORD;
    uint id : VERTEXID;
};

StructuredBuffer<SpriteVertex> spriteData : register(t0);

Texture2DArray mapDiffuse : register(t1);
Texture2DMSArray<float4> mapDiffuseMS : register(t2);
SamplerState diffuseSampler;

float4x4 wvp;
float2 vpSize;
float2 textureSize;
uint sampleCount = 8;
uint vertexOffset = 0;

static float degToRad360 = 6.28319;

VS_GS VS(uint vID : SV_VertexID)
{
    VS_GS output;

    output.vID = vID;
	return output;
}

const static float2 spriteCorners[4] = {
	float2(0,-1),
	float2(0, 0),
	float2(1,-1),
	float2(1,0),
};

// 0 = left, 1 = top, 2 = right, 3 = bottom
const static int2 uvTable[4] = {
	int2(0,3), // Bottom left
	int2(0,1), // Top left
	int2(2,3), // Bottom right
	int2(2,1), // Top right
};

float2x2 GetRotation(float angle)
{
	// Compute a 2x2 rotation matrix.
	float c = cos(angle);
	float s = sin(angle);

	return float2x2(c, -s, s, c);
}

[maxvertexcount(4)]
void GS(point VS_GS input[1], uint pID : SV_PrimitiveID, inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
    v.id = vertexOffset + input[0].vID;
    SpriteVertex sv = spriteData[v.id];
    float4 uv = sv.uv;

	v.col = sv.col;
    uv.xz /= textureSize.x; // scale left (x) and right(z) to 0 - 1.0 range.
	uv.yw /= textureSize.y; // Scale top (y) and bottom(w) to 0 - 1.0 range.

	float2x2 rot = GetRotation(sv.rotation);
	float2 origin = float2(sv.origin.x, -sv.origin.y);  // Invert y origin
	float2 pos = float2(sv.pos.x, -sv.pos.y);           // Invert y axis
	float2 size = sv.size.xy;
	float2 p;

	[unroll]
	for (int i = 0; i < 4; i++)
	{
		p = mul(size * (spriteCorners[i] - origin), rot);
		p += pos;
		v.pos = float4(p, 0, 1);
		v.pos = mul(v.pos, wvp);
		v.uv.x = uv[uvTable[i].x];
		v.uv.y = uv[uvTable[i].y];
		v.uv.z = sv.arraySlice;
		spriteStream.Append(v);
	}
}

float4 PS( PS_IN input ) : SV_Target
{
	float4 col = mapDiffuse.Sample(diffuseSampler, input.uv);
	return col * input.col;
}

float4 PS_NoTexture(PS_IN input) : SV_Target
{
	return input.col;
}

float4 PS_Circle(PS_IN input) : SV_Target
{   
    float2 dist = abs(input.uv.xy - 0.5); // Distance from quad center (0.5, 0.5)

    if(length(dist) > 0.5)
        discard;

   	float4 col = mapDiffuse.Sample(diffuseSampler, input.uv);
	return col * input.col;
}