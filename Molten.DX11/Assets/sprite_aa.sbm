<material>
  <name>triangle</name>
  <description>The default material for rendering an un-textured triangle from a single point.</description>
  <pass>
    <name>main</name>
    <iterations>1</iterations>
    <vertex>VS_Tri</vertex>
    <geometry>GS_Tri</geometry>
    <pixel>PS_NoTexture</pixel>
  </pass>
  <rasterizer>
    <multisample>true</multisample>
  </rasterizer>
</material>

struct VS_GS
{
	float2 pos : POSITION0;
	float2 size : POSITION1;
	float2 origin : POSITION2;
	float4 uv : POSITION3;
	float rotation : POSITION4;
	float4 col : COLOR;
};

struct PS_IN
{
	float4 pos : SV_POSITION;
	float4 col : COLOR;
	float2 uv : TEXCOORD;
};

Texture2D albedo;
SamplerState albedoSampler;

float4x4 worldViewProj;
float2 textureSize;

static float degToRad360 = 6.28319;

VS_GS VS(VS_GS input)
{
	input.uv.xz /= textureSize.x;
	input.uv.yw /= textureSize.y;

	//invert y axis.
	input.pos.y = -input.pos.y;

	// Invert Y origin
	input.origin.y = -input.origin.y;

	return input;
}

VS_GS VS_Tri(VS_GS input)
{
	//invert y axis.
	input.pos.y = -input.pos.y;
  input.size.y = -input.size.y;
  input.origin.y = -input.origin.y;
	return input;
}

const static float2 spriteCorners[4] = {
	float2(0,-1),
	float2(0, 0),
	float2(1,-1),
	float2(1,0),
};

const static int2 uvTable[4] = {
	int2(0,3),
	int2(0,1),
	int2(2,3),
	int2(2,1),
};

float2x2 GetRotation(float angle)
{
	// Compute a 2x2 rotation matrix.
	float c = cos(angle);
	float s = sin(angle);

	return float2x2(c, -s, s, c);
}

[maxvertexcount(4)]
void GS(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
	v.col = input[0].col;

	float2x2 rot = GetRotation(input[0].rotation);
	float2 origin = input[0].origin.xy;
	float2 pos = input[0].pos.xy;
	float2 size = input[0].size.xy;
	float4 uv = input[0].uv;
	float2 p;

	[unroll]
	for (int i = 0; i < 4; i++)
	{
		p = mul(size * (spriteCorners[i] - origin), rot);
		p += pos;
		v.pos = float4(p, 0, 1);
		v.pos = mul(v.pos, worldViewProj);
		v.uv.x = uv[uvTable[i].x];
		v.uv.y = uv[uvTable[i].y];
		spriteStream.Append(v);
	}
}

[maxvertexcount(3)]
void GS_Tri(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
  v.col = input[0].col;
  v.uv = float2(0,0);
  
  // p1
  v.pos = mul(float4(input[0].pos, 0, 1), worldViewProj);
  spriteStream.Append(v);
  
  // p3
  v.pos = mul(float4(input[0].origin, 0, 1), worldViewProj);
  spriteStream.Append(v);
  
  // p2
  v.pos = mul(float4(input[0].size, 0, 1), worldViewProj);
  spriteStream.Append(v);
}

float4 PS_NoTexture(PS_IN input) : SV_Target
{
	return input.col;
}
