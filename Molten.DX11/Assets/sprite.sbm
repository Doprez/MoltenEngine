<material>
	<name>sprite-texture</name>
	<description>The default material for rendering sprites in a SpriteBatch with a texture</description>
	<pass>
		<name>main</name>
		<iterations>1</iterations>
		<vertex>VS</vertex>
		<geometry>GS</geometry>
		<pixel>PS</pixel>
	</pass>
</material>

<material>
	<name>sprite-no-texture</name>
	<description>The default material for rendering sprites in a SpriteBatch with no texture.</description>
	<pass>
		<name>main</name>
		<iterations>1</iterations>
		<vertex>VS</vertex>
		<geometry>GS</geometry>
		<pixel>PS_NoTexture</pixel>
	</pass>
</material>

struct VS_GS
{
	float2 pos : POSITION0;
	float2 size : POSITION1;
	float2 origin : POSITION2;
	float4 uv : POSITION3;
	float rotation : POSITION4;
	float4 col : COLOR;
};

struct PS_IN
{
	float4 pos : SV_POSITION;
	float4 col : COLOR;
	float2 uv : TEXCOORD;
};

Texture2D albedo;
SamplerState albedoSampler;

float4x4 worldViewProj;
float2 textureSize;

VS_GS VS(VS_GS input)
{
	input.uv.xz /= textureSize.x;
	input.uv.yw /= textureSize.y;

	//invert y axis.
	input.pos.y = -input.pos.y;

	// Invert Y origin
	input.origin.y = -input.origin.y;

	return input;
}

const static float2 spriteCorners[4] = {
	float2(0,-1),
	float2(0, 0),
	float2(1,-1),
	float2(1,0),
};

const static int2 uvTable[4] = {
	int2(0,3),
	int2(0,1),
	int2(2,3),
	int2(2,1),
};

float2x2 GetRotation(float angle)
{
	// Compute a 2x2 rotation matrix.
	float c = cos(angle);
	float s = sin(angle);

	return float2x2(c, -s, s, c);
}

[maxvertexcount(4)]
void GS(point VS_GS input[1], inout TriangleStream<PS_IN> spriteStream)
{
	PS_IN v;
	v.col = input[0].col;

	float2x2 rot = GetRotation(input[0].rotation);
	float2 origin = input[0].origin.xy;
	float2 pos = input[0].pos.xy;
	float2 size = input[0].size.xy;
	float4 uv = input[0].uv;
	float2 p;

	[unroll]
	for (int i = 0; i < 4; i++)
	{
		p = mul(size * (spriteCorners[i] - origin), rot);
		p += pos;
		v.pos = float4(p, 0, 1);
		v.pos = mul(v.pos, worldViewProj);
		v.uv.x = uv[uvTable[i].x];
		v.uv.y = uv[uvTable[i].y];
		spriteStream.Append(v);
	}
}

float median(float r, float g, float b) {
    return max(min(r, g), min(max(r, g), b));
}

float4 PS( PS_IN input ) : SV_Target
{
	float4 col = albedo.Sample(albedoSampler, input.uv);
	return col * input.col;
}

float4 PS_NoTexture(PS_IN input) : SV_Target
{
	return input.col;
}
