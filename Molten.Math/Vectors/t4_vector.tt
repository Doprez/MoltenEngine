<#@ template debug="false" hostspecific="true" language="C#" #>

<#@ include file="t4_helpers.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

<#
string outputPath = this.Host.ResolvePath("");
string[] _types = new string[]{"sbyte", "byte", "int", "uint", "short", "ushort", "long", "ulong", "float", "double", "decimal", "nint", "nuint"};
string[] _names = new string[]{"SByte", "Byte", "Vector", "Vector", "Half", "Half", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector"};
string[] _postfixes = new string[]{"", "", "I", "UI", "", "U", "L", "UL", "F", "D", "M", "N", "NU"};
int[] _pack = new int[]{1, 1, 4, 4 , 2, 2, 8, 8, 4, 8, 16, 0, 0};
string[] _one = new string[]{"1", "1", "1", "1U", "(short)1", "(ushort)1", "1L", "1UL", "1F", "1D", "1M", "1", "1U"};
string[] _zero = new string[]{"0", "0", "0", "0U", "0", "0", "0L", "0UL", "0F", "0D", "0M", "0", "0U"};
string _propertyMap = "xyzw";
string _propertyMapUpper = "XYZW";

int[] _sizes = new int[]{2, 3, 4};

for(int i = 0; i < _types.Length; i++)
{
	string tName = _types[i];

	foreach(int size in _sizes)
	{
		string fullName = $"{_names[i]}{size}{_postfixes[i]}";
		string fn = $"{fullName}";
#>
using System.Runtime.InteropServices;

namespace Molten.Math
{
	///<summary>A <see cref = "<#=_types[i]#>"/> vector comprised of <#=size#> components.</summary>
	[StructLayout(LayoutKind.Sequential, Pack=<#=_pack[i]#>)]
	public partial struct <#=fullName#>
	{
<#
		for(int p = 0; p < size; p++)
		{
#>
		///<summary>The <#=_propertyMapUpper[p]#> component.</summary>
		public <#=_types[i]#> <#=_propertyMapUpper[p]#>;

<#
		}
#>

		///<summary>The size of <see cref="<#=fullName#>"/>, in bytes.</summary>
		public static readonly int SizeInBytes = Marshal.SizeOf(typeof(<#=fullName#>));

		public static <#=fullName#> One = new <#=fullName#>(<#for(int p = 0; p < size; p++){#><#=_one[i]#><#=(p < (size-1) ? ", " : "")#><#}#>);

		public static <#=fullName#> Zero = new <#=fullName#>(<#for(int p = 0; p < size; p++){#><#=_zero[i]#><#=(p < (size-1) ? ", " : "")#><#}#>);

		///<summary>Creates a new instance of <see cref = "<#=fullName#>"/></summary>
		public <#=fullName#>(<#=GetConstructorArgs(tName, _propertyMap, size)#>)
		{
<#
		for(int p = 0; p < size; p++)
		{
#>
			<#=_propertyMapUpper[p]#> = <#=_propertyMap[p]#>;
<#
		}
#>
		}

#region Common Functions
		/// <summary>
        /// Calculates the squared distance between two <see cref="<#=fullName#>"/> vectors.
        /// </summary>
        /// <param name="value1">The first vector.</param>
        /// <param name="value2">The second vector</param>
        /// <param name="result">When the method completes, contains the squared distance between the two vectors.</param>
        /// <remarks>Distance squared is the value before taking the square root. 
        /// Distance squared can often be used in place of distance if relative comparisons are being made. 
        /// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
        /// compare the distance between A and B to the distance between A and C. Calculating the two distances 
        /// involves two square roots, which are computationally expensive. However, using distance squared 
        /// provides the same information and avoids calculating two square roots.
        /// </remarks>
		public static void DistanceSquared(ref <#=fullName#> value1, ref <#=fullName#> value2, out <#=_types[i]#> result)
        {
<#
			string r ="";
			for(int d = 0; d < size; d++)
			{
				r+= $"({_propertyMap[d]} * {_propertyMap[d]}){(d < (size-1) ? " + " : "")}";
#>
            <#=_types[i]#> <#=_propertyMap[d]#> = value1.<#=_propertyMapUpper[d]#> - value2.<#=_propertyMapUpper[d]#>;
<#
			}
#>

            result = <#=r#>;
        }
#endregion

#region Add operators
		public static <#=fullName#> operator +(<#=fullName#> left, <#=fullName#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> + right.<#=_propertyMapUpper[p]#><#=(p < (size-1) ? ", " : "")#><#}#>);
		}

		public static <#=fullName#> operator +(<#=fullName#> left, <#=_types[i]#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> + right<#=(p < (size-1) ? ", " : "")#><#}#>);
		}
#endregion

#region Subtract operators
		public static <#=fullName#> operator -(<#=fullName#> left, <#=fullName#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> - right.<#=_propertyMapUpper[p]#><#=(p < (size-1) ? ", " : "")#><#}#>);
		}

		public static <#=fullName#> operator -(<#=fullName#> left, <#=_types[i]#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> - right<#=(p < (size-1) ? ", " : "")#><#}#>);
		}
#endregion

#region division operators
		public static <#=fullName#> operator /(<#=fullName#> left, <#=fullName#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> / right.<#=_propertyMapUpper[p]#><#=(p < (size-1) ? ", " : "")#><#}#>);
		}

		public static <#=fullName#> operator /(<#=fullName#> left, <#=_types[i]#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> / right<#=(p < (size-1) ? ", " : "")#><#}#>);
		}
#endregion

#region Multiply operators
		public static <#=fullName#> operator *(<#=fullName#> left, <#=fullName#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> * right.<#=_propertyMapUpper[p]#><#=(p < (size-1) ? ", " : "")#><#}#>);
		}

		public static <#=fullName#> operator *(<#=fullName#> left, <#=_types[i]#> right)
		{
			return new <#=fullName#>(<#for(int p = 0; p < size; p++){#>left.<#=_propertyMapUpper[p]#> * right<#=(p < (size-1) ? ", " : "")#><#}#>);
		}
#endregion
	}
}
<#
		SaveFile(outputPath, fn, this.GenerationEnvironment.ToString());
		this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
	}
}
#>
