<#@ template debug="false" hostspecific="true" language="C#" #>

<#@ include file="../t4_header.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

<#
string outputPath = this.Host.ResolvePath("");
List<TypeData> _def = ReadJsonDef<TypeData>(outputPath, "quaternion_defs.json");
string _pMap = "xyzw";
string _pMapUpper = "XYZW";

foreach(TypeData d in _def)
{
	if(!d.IsFPType)
	{
		continue;
	}

	string fullName = $"{d.Name}{d.Postfix}";
    string vectorName = $"Vector3{d.Postfix}";
	string fn = $"{fullName}";
#>
using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Molten.Math
{
	///<summary>Represents a four dimensional mathematical <#=fullName#>.</summary>
	[StructLayout(LayoutKind.Sequential, Pack = <#=d.Pack#>)]
	public partial struct <#=fullName#> : IFormattable, IEquatable<<#=fullName#>>
	{
		/// <summary>
        /// The size of the <#=SeeRef(fullName)#> type, in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(typeof(<#=fullName#>));

		 /// <summary>
        /// A <see cref="<#=fullName#>"/> with all of its components set to zero.
        /// </summary>
        public static readonly <#=fullName#> Zero = new <#=fullName#>();

        /// <summary>
        /// A <see cref="<#=fullName#>"/> with all of its components set to one.
        /// </summary>
        public static readonly <#=fullName#> One = new <#=fullName#>(<#=d.One#>, <#=d.One#>, <#=d.One#>, <#=d.One#>);

        /// <summary>
        /// The identity <see cref="<#=fullName#>"/> (0, 0, 0, 1).
        /// </summary>
        public static readonly <#=fullName#> Identity = new <#=fullName#>(<#=d.Zero#>, <#=d.Zero#>, <#=d.Zero#>, <#=d.Zero#>);

		///<summary>The X component of the <#=fullName#>.</summary>
		public <#=d.DT#> X;

        ///<summary>The Y component of the <#=fullName#>.</summary>
		public <#=d.DT#> Y;

        ///<summary>The Z component of the <#=fullName#>.</summary>
		public <#=d.DT#> Z;

        ///<summary>The W component of the <#=fullName#>.</summary>
		public <#=d.DT#> W;

        /// <summary>
        /// Gets a value indicting whether this  <see cref="<#=fullName#>"/> is normalized.
        /// </summary>
        public bool IsNormalized
        {
            get { return MathHelper.IsOne((X * X) + (Y * Y) + (Z * Z) + (W * W)); }
        }

        /// <summary>
        /// Gets the angle of the  <see cref="<#=fullName#>"/>.
        /// </summary>
        /// <value>The quaternion's angle.</value>
        public float Angle
        {
            get
            {
                float length = (X * X) + (Y * Y) + (Z * Z);
                if (MathHelper.IsZero(length))
                    return 0.0<#=d.FPL#>;

                return <#=(d.DT == "float" ? "(float)" : "")#>(2.0 * Math.Acos(MathHelper.Clamp(W, -1<#=d.FPL#>, 1<#=d.FPL#>)));
            }
        }

        /// <summary>
        /// Gets the axis components of the <#=fullName#>.
        /// </summary>
        /// <value>The axis components of the <#=fullName#>.</value>
        public Vector3<#=d.Postfix#> Axis
        {
            get
            {
                <#=d.DT#> length = (X * X) + (Y * Y) + (Z * Z);
                if (MathHelper.IsZero(length))
                    return Vector3F.UnitX;

                <#=d.DT#> inv = 1.0<#=d.FPL#>  / <#=(d.DT == "float" ? "(float)" : "")#>Math.Sqrt(length);
                return new Vector3<#=d.Postfix#>(X * inv, Y * inv, Z * inv);
            }
        }

#region Constructors
        /// <summary>
        /// Initializes a new instance of the <#=SeeRef(fullName)#> struct.
        /// </summary>
        /// <param name="value">A <#=fullName#> containing the values with which to initialize the components.</param>
        public <#=fullName#>(Vector4<#=d.Postfix#> value)
        {
            X = value.X;
            Y = value.Y;
            Z = value.Z;
            W = value.W;
        }

        /// <summary>
        /// Initializes a new instance of the <#=SeeRef(fullName)#> struct.
        /// </summary>
        /// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
        /// <param name="w">Initial value for the W component of the <#=SeeRef(fullName)#>.</param>
        public <#=fullName#>(<#=vectorName#> value, <#=d.DT#> w)
        {
            X = value.X;
            Y = value.Y;
            Z = value.Z;
            W = w;
        }

        /// <summary>
        /// Initializes a new instance of the <#=SeeRef(fullName)#> struct.
        /// </summary>
        /// <param name="value">A vector containing the values with which to initialize the X and Y components.</param>
        /// <param name="z">Initial value for the Z component of the <#=SeeRef(fullName)#>.</param>
        /// <param name="w">Initial value for the W component of the <#=SeeRef(fullName)#>.</param>
        public <#=fullName#>(Vector2<#=d.Postfix#> value, <#=d.DT#> z, <#=d.DT#> w)
        {
            X = value.X;
            Y = value.Y;
            Z = z;
            W = w;
        }

        /// <summary>
        /// Initializes a new instance of the <#=SeeRef(fullName)#> struct.
        /// </summary>
        /// <param name="x">Initial value for the X component of the <#=SeeRef(fullName)#>.</param>
        /// <param name="y">Initial value for the Y component of the <#=SeeRef(fullName)#>.</param>
        /// <param name="z">Initial value for the Z component of the <#=SeeRef(fullName)#>.</param>
        /// <param name="w">Initial value for the W component of the <#=SeeRef(fullName)#>.</param>
        public <#=fullName#>(<#=d.DT#> x, <#=d.DT#> y, <#=d.DT#> z, <#=d.DT#> w)
        {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        
        /// <summary>
        /// Initializes a new instance of the  <#=SeeRef(fullName)#> struct.
        /// </summary>
        /// <param name="values">The values to assign to the X, Y, Z, and W components of the quaternion. This must be an array with four elements.</param>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
        public <#=fullName#>(<#=d.DT#>[] values)
        {
            if (values == null)
                throw new ArgumentNullException("values");
            if (values.Length != 4)
                throw new ArgumentOutOfRangeException("values", "There must be four and only four input values for <#=fullName#>.");

            X = values[0];
            Y = values[1];
            Z = values[2];
            W = values[3];
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=fullName#>"/> struct from an unsafe pointer. The pointer should point to an array of four elements.
        /// </summary>
        public unsafe <#=fullName#>(<#=d.DT#>* ptr)
		{
            X = ptr[0];
            Y = ptr[1];
            Z = ptr[2];
            W = ptr[3];
		}
#endregion

#region Instance Methods
/// <summary>
        /// Gets a value indicating whether this instance is equivalent to the identity <#=fullName#>.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is an identity <#=fullName#>; otherwise, <c>false</c>.
        /// </value>
        public bool IsIdentity
        {
            get { return this.Equals(Identity); }
        }

        /// <summary>
        /// Conjugates the <#=SeeRef(fullName)#> X,Y and Z components. W component is not changed.
        /// </summary>
        public void Conjugate()
        {
            X = -X;
            Y = -Y;
            Z = -Z;
        }

        /// <summary>
        /// Conjugates the <#=SeeRef(fullName)#>.
        /// </summary>
        public void Abs()
        {
            X = Math.Abs(X);
            Y = Math.Abs(Y);
            Z = Math.Abs(Z);
            W = Math.Abs(W);
        }

        /// <summary>
        /// Calculates the squared length of the <#=SeeRef(fullName)#>.
        /// </summary>
        /// <returns>The squared length of the <#=SeeRef(fullName)#>.</returns>
        /// <remarks>
        /// This method may be preferred to <see cref="<#=fullName#>.Length"/> when only a relative length is needed
        /// and speed is of the essence.
        /// </remarks>
        public <#=d.DT#> LengthSquared()
        {
            return (X * X) + (Y * Y) + (Z * Z) + (W * W);
        }

        /// <summary>
        /// Creates an array containing the elements of the <#=SeeRef(fullName)#>.
        /// </summary>
        /// <returns>A four-element array containing the components of the <#=SeeRef(fullName)#>.</returns>
        public <#=d.DT#>[] ToArray()
        {
            return new <#=d.DT#>[] { X, Y, Z, W };
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
        /// </returns>
        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = X.GetHashCode();
                hashCode = (hashCode * 397) ^ Y.GetHashCode();
                hashCode = (hashCode * 397) ^ Z.GetHashCode();
                hashCode = (hashCode * 397) ^ W.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// Computes the quaternion rotation between two normalized vectors.
        /// </summary>
        /// <param name="v1">First unit-length vector.</param>
        /// <param name="v2">Second unit-length vector.</param>
        /// <param name="q">Quaternion representing the rotation from v1 to v2.</param>
        public static <#=fullName#> GetQuaternionBetweenNormalizedVectors(ref <#=vectorName#> v1, ref <#=vectorName#> v2)
        {
            <#=d.DT#> dot;
            <#=fullName#> q;
            <#=vectorName#>.Dot(ref v1, ref v2, out dot);
            //For non-normal vectors, the multiplying the axes length squared would be necessary:
            //float w = dot + (float)Math.Sqrt(v1.LengthSquared() * v2.LengthSquared());
            if (dot < -0.9999<#=d.FPL#>) //parallel, opposing direction
            {
                //If this occurs, the rotation required is ~180 degrees.
                //The problem is that we could choose any perpendicular axis for the rotation. It's not uniquely defined.
                //The solution is to pick an arbitrary perpendicular axis.
                //Project onto the plane which has the lowest component magnitude.
                //On that 2d plane, perform a 90 degree rotation.
                <#=d.DT#> absX = Math.Abs(v1.X);
                <#=d.DT#> absY = Math.Abs(v1.Y);
                <#=d.DT#> absZ = Math.Abs(v1.Z);
                if (absX < absY && absX < absZ)
                    q = new <#=fullName#>(0, -v1.Z, v1.Y, 0);
                else if (absY < absZ)
                    q = new <#=fullName#>(-v1.Z, 0, v1.X, 0);
                else
                    q = new <#=fullName#>(-v1.Y, v1.X, 0, 0);
            }
            else
            {
                <#=vectorName#> axis;
                <#=vectorName#>.Cross(ref v1, ref v2, out axis);
                q = new <#=fullName#>(axis.X, axis.Y, axis.Z, dot + 1);
            }
            q.Normalize();

            return q;
        }

        /// <summary>
        /// Converts the <#=SeeRef(fullName)#> into a unit quaternion.
        /// </summary>
        public void Normalize()
        {
            <#=d.DT#> length = Length();
            if (!MathHelper.IsZero(length))
            {
                <#=d.DT#> inverse = 1.0<#=d.FPL#> / length;
                X *= inverse;
                Y *= inverse;
                Z *= inverse;
                W *= inverse;
            }
        }

        /// <summary>
        /// Calculates the length of the <#=fullName#>.
        /// </summary>
        /// <returns>The length of the <#=fullName#>.</returns>
        /// <remarks>
        /// <see cref="<#=fullName#>.LengthSquared"/> may be preferred when only the relative length is needed and speed is of the essence.
        /// </remarks>
        public <#=d.DT#> Length()
        {
            return <#=(d.DT == "float" ? "(float)" : "")#>Math.Sqrt((X * X) + (Y * Y) + (Z * Z) + (W * W));
        }

        /// <summary>
        /// Conjugates and renormalizes the <#=fullName#>.
        /// </summary>
        public void Invert()
        {
            <#=d.DT#> lengthSq = LengthSquared();
            if (!MathHelper.IsZero(lengthSq))
            {
                lengthSq = 1.0<#=d.FPL#> / lengthSq;

                X = -X * lengthSq;
                Y = -Y * lengthSq;
                Z = -Z * lengthSq;
                W = W * lengthSq;
            }
        }

        /// <summary>
        /// Determines whether the specified <#=SeeRef(fullName)#> is equal to this instance.
        /// </summary>
        /// <param name="other">The <#=SeeRef(fullName)#> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <#=SeeRef(fullName)#> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(ref <#=fullName#> other)
        {
            return MathHelper.NearEqual(other.X, X) && MathHelper.NearEqual(other.Y, Y) && MathHelper.NearEqual(other.Z, Z) && MathHelper.NearEqual(other.W, W);
        }

        /// <summary>
        /// Determines whether the specified <#=SeeRef(fullName)#> is equal to this instance.
        /// </summary>
        /// <param name="other">The <#=SeeRef(fullName)#> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <#=SeeRef(fullName)#> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=fullName#> other)
        {
            return Equals(ref other);
        }

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="value">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object value)
        {
            if (!(value is <#=fullName#>))
                return false;

            var strongValue = (<#=fullName#>)value;
            return Equals(ref strongValue);
        }

        /// <summary>
        /// Computes the angle change represented by a normalized quaternion.
        /// </summary>
        /// <param name="q">Quaternion to be converted.</param>
        /// <returns>Angle around the axis represented by the quaternion.</returns>
        public static <#=d.DT#> GetAngleFromQuaternion(ref <#=fullName#> q)
        {
            <#=d.DT#> qw = Math.Abs(q.W);
            if (qw > 1)
                return 0;
            return 2 * (<#=d.DT#>)Math.Acos(qw);
        }
#endregion

#region To-String Methods
/// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "X:{0} Y:{1} Z:{2} W:{3}", X, Y, Z, W);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(string format)
        {
            if (format == null)
                return ToString();

            return string.Format(CultureInfo.CurrentCulture, "X:{0} Y:{1} Z:{2} W:{3}", X.ToString(format, CultureInfo.CurrentCulture),
                Y.ToString(format, CultureInfo.CurrentCulture), Z.ToString(format, CultureInfo.CurrentCulture), W.ToString(format, CultureInfo.CurrentCulture));
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(IFormatProvider formatProvider)
        {
            return string.Format(formatProvider, "X:{0} Y:{1} Z:{2} W:{3}", X, Y, Z, W);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
                return ToString(formatProvider);

            return string.Format(formatProvider, "X:{0} Y:{1} Z:{2} W:{3}", X.ToString(format, formatProvider),
                Y.ToString(format, formatProvider), Z.ToString(format, formatProvider), W.ToString(format, formatProvider));
        }
#endregion

#region Static Methods
        /// <summary>
        /// Multiplies two <#=SeeRef(fullName)#> together in opposite order.
        /// </summary>
        /// <param name="a">First <#=SeeRef(fullName)#> to multiply.</param>
        /// <param name="b">Second <#=SeeRef(fullName)#> to multiply.</param>
        public static <#=fullName#> Concatenate(ref <#=fullName#> a, ref <#=fullName#> b)
        {
            <#=d.DT#> aX = a.X;
            <#=d.DT#> aY = a.Y;
            <#=d.DT#> aZ = a.Z;
            <#=d.DT#> aW = a.W;
            <#=d.DT#> bX = b.X;
            <#=d.DT#> bY = b.Y;
            <#=d.DT#> bZ = b.Z;
            <#=d.DT#> bW = b.W;

            return new <#=fullName#>()
            {
                X = aW * bX + aX * bW + aZ * bY - aY * bZ,
                Y = aW * bY + aY * bW + aX * bZ - aZ * bX,
                Z = aW * bZ + aZ * bW + aY * bX - aX * bY,
                W = aW * bW - aX * bX - aY * bY - aZ * bZ
            };
        }
#endregion

#region Operators - Multiply
        /// <summary>
        /// Scales a quaternion by the given value.
        /// </summary>
        /// <param name="value">The quaternion to scale.</param>
        /// <param name="scale">The amount by which to scale the quaternion.</param>
        /// <returns>The scaled quaternion.</returns>
        public static <#=fullName#> operator *(<#=d.DT#> scale, <#=fullName#> value)
        {
            return new <#=fullName#>()
            {
                X = value.X * scale,
                Y = value.Y * scale,
                Z = value.Z * scale,
                W = value.W * scale,
            };
        }

        /// <summary>
        /// Scales a quaternion by the given value.
        /// </summary>
        /// <param name="value">The quaternion to scale.</param>
        /// <param name="scale">The amount by which to scale the quaternion.</param>
        /// <returns>The scaled quaternion.</returns>
        public static <#=fullName#> operator *(<#=fullName#> value, <#=d.DT#> scale)
        {
            return new <#=fullName#>()
            {
                X = value.X * scale,
                Y = value.Y * scale,
                Z = value.Z * scale,
                W = value.W * scale,
            };
        }

        /// <summary>
        /// Multiplies a quaternion by another.
        /// </summary>
        /// <param name="left">The first quaternion to multiply.</param>
        /// <param name="right">The second quaternion to multiply.</param>
        /// <returns>The multiplied quaternion.</returns>
        public static <#=fullName#> operator *(<#=fullName#> left, <#=fullName#> right)
        {
            <#=d.DT#> lx = left.X;
            <#=d.DT#> ly = left.Y;
            <#=d.DT#> lz = left.Z;
            <#=d.DT#> lw = left.W;
            <#=d.DT#> rx = right.X;
            <#=d.DT#> ry = right.Y;
            <#=d.DT#> rz = right.Z;
            <#=d.DT#> rw = right.W;
            <#=d.DT#> a = (ly * rz - lz * ry);
            <#=d.DT#> b = (lz * rx - lx * rz);
            <#=d.DT#> c = (lx * ry - ly * rx);
            <#=d.DT#> d = (lx * rx + ly * ry + lz * rz);

            return new <#=fullName#>()
            {
                X = (lx * rw + rx * lw) + a,
                Y = (ly * rw + ry * lw) + b,
                Z = (lz * rw + rz * lw) + c,
                W = lw * rw - d
            };
        }
#endregion

#region Operators - Subtract
        /// <summary>
        /// Subtracts two quaternions.
        /// </summary>
        /// <param name="left">The first quaternion to subtract.</param>
        /// <param name="right">The second quaternion to subtract.</param>
        /// <returns>The difference of the two quaternions.</returns>
        public static <#=fullName#> operator -(<#=fullName#> left, <#=fullName#> right)
        {
            return new <#=fullName#>()
            {
            X = left.X - right.X,
            Y = left.Y - right.Y,
            Z = left.Z - right.Z,
            W = left.W - right.W
            };
        }

        /// <summary>
        /// Reverses the direction of a given quaternion.
        /// </summary>
        /// <param name="value">The quaternion to negate.</param>
        /// <returns>A quaternion facing in the opposite direction.</returns>
        public static <#=fullName#> operator -(<#=fullName#> value)
        {
            return new <#=fullName#>()
            {
                X = -value.X,
                Y = -value.Y,
                Z = -value.Z,
                W = -value.W
            };
        }
#endregion

#region Indexers
/// <summary>
        /// Gets or sets the component at the specified index.
        /// </summary>
        /// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
        /// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
        /// <returns>The value of the component at the specified index.</returns>
        /// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
        public <#=d.DT#> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    case 2: return Z;
                    case 3: return W;
                }

                throw new ArgumentOutOfRangeException("index", "Indices for <#=fullName#> run from 0 to 3, inclusive.");
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    case 2: Z = value; break;
                    case 3: W = value; break;
                    default: throw new ArgumentOutOfRangeException("index", "Indices for <#=fullName#> run from 0 to 3, inclusive.");
                }
            }
        }
#endregion
	}
}
<#
	SaveFile(outputPath, fn, this.GenerationEnvironment.ToString());
	this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>
