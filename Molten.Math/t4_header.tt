<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ output extension=".cs" #>


<#+
public delegate void GenerateTypeCallback(TypeDef d, Metadata md, List<TypeDef> defs);
public delegate bool GenerateTypeFilter(TypeDef d, Metadata md);


public class DataType
{
    // Populated by deserialization
    public string Name;
    public string TypeName;
    public string Literal;
    public string FPDataType;

    // Populated after deserialization
    public Type UnderlyingType;
    public DataType FP;
    public int Bits;
    public int Pack;
    public string One;
    public string Zero;
    public bool IsFPType;
    public bool IsUnsigned;
    public string FPCast;
    public string Math; //Which math class to use. Math or MathF.
    public string TypeCast;
    public string FPToTypeCast;
    public string IntType;

    public string SubNamespace;
    public string SubDirectory;

    public override string ToString()
    {
        return Name;
    }

    public static bool operator ==(DataType dt, string str){
        return dt?.Name == str;
    }

    public static bool operator !=(DataType dt, string str){
        return dt?.Name != str;
    }

    public static bool operator ==(string str, DataType dt){
        return str != dt?.Name;
    }

    public static bool operator !=(string str, DataType dt){
        return str != dt?.Name;
    }
}

public class TypeDef
{
    public string Name;         // Name
    public string Postfix;      //Name post-fix
    public DataType DT;         // The underlying DataType definition.
    public string DataTypeName;  // The name of the DataType to be used.

    public DataType FP => DT.FP;
}

public class Metadata
{
    public int Size;
	public string Name;
	public string Filename;
    public string FilePostFix;
}

string[] _strSize = new string[]{"zero", "one", "two", "three", "four", "five", "six", "seven", "eight"};
int[] _vectorSizes = new int[]{2, 3, 4};

public void GenerateTypes(
    StringBuilder genEnvironment, 
    ITextTemplatingEngineHost host, 
    string subFolder, 
    string definitionFileName, 
    string filePostFix, 
    int[] sizes, 
    GenerateTypeFilter filter,
    GenerateTypeCallback callback)
{
    string outputPath = host.ResolvePath("");

    // Load supported data types and build metadata for them.
    List<DataType> supportedDataTypes = ReadJsonDef<DataType>(outputPath, "def_datatypes.json");
    Dictionary<string, DataType> dataTypes = new Dictionary<string, DataType>();

    foreach(DataType dt in supportedDataTypes)
    {
        dt.UnderlyingType = Type.GetType(dt.TypeName);
        if(dt.UnderlyingType == null)
            continue;

        dataTypes[dt.Name] = dt;

        // Check deserialized values
        dt.Literal = string.IsNullOrWhiteSpace(dt.Literal) ? "" : dt.Literal;

        dt.Pack = Marshal.SizeOf(dt.UnderlyingType);
        dt.Bits = dt.Pack * 8;
        dt.One = string.IsNullOrWhiteSpace(dt.One) ? ("1" + dt.Literal) : dt.One;
        dt.Zero = string.IsNullOrWhiteSpace(dt.Zero) ? ("0" + dt.Literal) : dt.Zero;
        dt.IsFPType = dt.FPDataType == dt.Name;
        dt.IsUnsigned = dt.Name.StartsWith("u") || dt.Name == "byte";
        dt.FPCast = dt.Name == "float" ? "(float)" : (dt.Name == "double" ? "" : $"({dt.Name})");
        dt.Math = dt.Name == "float" ? "MathF" : "Math";
        dt.TypeCast = (dt.Name == "byte" || dt.Name == "sbyte" || dt.Name == "short" || dt.Name == "ushort") ? $"({dt.Name})" : "";
        dt.FPToTypeCast = (dt.TypeCast.Length > 0) ? dt.TypeCast : (dt.Name != dt.FPDataType ? $"({dt.Name})" : "");
        dt.IntType = (dt.Name == "byte" || dt.Name == "sbyte" || dt.Name == "short" || dt.Name == "ushort") ? $"int" : dt.Name;

        switch(dt.Bits){
            case 16:
                dt.SubNamespace = ".HalfPrecision"; 
                dt.SubDirectory = $"/HalfPrecision/{subFolder}";
                break;

            case 64: 
                dt.SubNamespace = ".DoublePrecision"; 
                dt.SubDirectory = $"/DoublePrecision/{subFolder}";
                break;

            case 128: 
                dt.SubNamespace = ".QuadPrecision"; 
                dt.SubDirectory = $"/QuadPrecision/{subFolder}";
                break;

            default:
                dt.SubDirectory = $"/SinglePrecision/{subFolder}";
                dt.SubNamespace = "";
                break;
        }
    }

    // Assign floating point type names.
    foreach(DataType dt in supportedDataTypes){
        if(dt.FPDataType == dt.Name)
            dt.FP = dt;
        else
            dataTypes.TryGetValue(dt.FPDataType, out dt.FP);
    }

    List<TypeDef> defs = ReadJsonDef<TypeDef>(outputPath, definitionFileName);
    Metadata md = new Metadata();
    sizes = sizes ?? new int[] {1};

    foreach(TypeDef t in defs)
    {
        if(dataTypes.ContainsKey(t.DataTypeName))
            t.DT = dataTypes[t.DataTypeName];
    }

    foreach(TypeDef t in defs)
    {
        if(!string.IsNullOrWhiteSpace(filePostFix))
            md.FilePostFix = $".{filePostFix}";
        else
            md.FilePostFix = "";

        foreach(int size in sizes)
        {
            md.Size = size;

            if(filter != null && !filter(t, md))
                continue;

            md.Name = $"{t.Name}{size}{t.Postfix}";
            genEnvironment.Length = 0;

            callback(t, md, defs);

		    md.Filename = $"{md.Name}{md.FilePostFix}";

            SaveFile(outputPath + t.DT.SubDirectory, md.Filename, genEnvironment.ToString());
		    genEnvironment.Length = 0;
        }
    }
}

public void SaveFile(string folder, string fileName, string content)
{
    string path = Path.Combine(folder, fileName.Trim() + ".cs");
    if(!Directory.Exists(folder))
        Directory.CreateDirectory(folder);

	using (FileStream fs = new FileStream(path, FileMode.Create))
    {
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
}

public List<T> ReadJsonDef<T>(string folder, string fileName) where T : class
{
    string json = File.ReadAllText(Path.Combine(folder, fileName.Trim()));
    return JsonConvert.DeserializeObject<List<T>>(json);
}

public string GetConstructorArgs(DataType type, string map, int count, string prefix = "", string postfix = "")
{
    if(map.Length < count)
        throw new Exception("Map length is shorter than count");
        
    string r = "";
    for(int i = 0; i < count; i++)
    {
        if(i > 0) r += ", ";
        r += $"{type.Name} {prefix}{map[i]}{postfix}";
    }

    return r;
}

public string GetParamSentence(string pMap, int size, string delimiter = ", ", string finalDelimiter = "", string pPrefix = "", string pPostfix = "")
{
    string r = "";
    for(int i = 0; i < size; i++)
    {
        r += $"{pPrefix}{pMap[i]}{pPostfix}";
        r += i < (size - 1) ? (i < (size - 2) ? ", " : finalDelimiter) : ""; 
    }

    return r;
}

public string See(string typeName)
{
    return $"<see cref=\"{typeName}\"/>";
}
#>
