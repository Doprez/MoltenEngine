<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ output extension=".cs" #>


<#+
public delegate void GenerateTypeCallback(TypeData d, Metadata md, List<TypeData> defs);
public delegate bool GenerateTypeFilter(TypeData d, Metadata md);

public class TypeData
{
    public string Name;     // Name
    public string Postfix;  //Name post-fix
    public string DT;       // DataType
    public string FP;       // Floating-point type
    public string FPL;      // Floating-point literal
    public string Pack;     // Packing
    public string One;      // Value for 1 or One
    public string Zero;     // Value for 0 or Zero
    public bool IsFPType;   // The type is a floating-point type
    public bool Unsigned;   // The type uses an unsigned data type
    public int Bits;        // The number of bits in DT
}

public class Metadata
{
    public int Size;
	public string Name;
	public string Filename;
    public string FilePostFix;
	public string FPCast;
	public string MathHelper;
    public string Math;
    public string TypeCast;
    public string FPToTypeCast;
    public string IntType;
    public string SubNamespace;
    public string SubDirectory;
}

string[] _strSize = new string[]{"zero", "one", "two", "three", "four", "five", "six", "seven", "eight"};
int[] _vectorSizes = new int[]{2, 3, 4};

public void GenerateTypes(
    StringBuilder genEnvironment, 
    ITextTemplatingEngineHost host, 
    string subFolder, 
    string definitionFileName, 
    string filePostFix, 
    int[] sizes, 
    GenerateTypeFilter filter,
    GenerateTypeCallback callback)
{
    string outputPath = host.ResolvePath("");
    List<TypeData> defs = ReadJsonDef<TypeData>(outputPath, definitionFileName);
    Metadata md = new Metadata();
    sizes = sizes ?? new int[] {1};

    foreach(TypeData d in defs)
    {
		md.FPCast = d.DT == "float" ? "(float)" : (d.DT == "double" ? "" : $"({d.DT})");
		md.MathHelper = d.FP == "double" ? "MathHelperDP" : "MathHelper";
		md.Math = d.FP == "float" ? "MathF" : "Math";
        md.TypeCast = (d.DT == "byte" || d.DT == "sbyte" || d.DT == "short" || d.DT == "ushort") ? $"({d.DT})" : "";
        md.FPToTypeCast = (md.TypeCast.Length > 0) ? md.TypeCast : (d.DT != d.FP ? $"({d.DT})" : "");
        md.IntType = (d.DT == "byte" || d.DT == "sbyte" || d.DT == "short" || d.DT == "ushort") ? $"int" : d.DT;
        md.SubNamespace = "";
        md.SubDirectory = "";

        if(!string.IsNullOrWhiteSpace(filePostFix))
            md.FilePostFix = $".{filePostFix}";
        else
            md.FilePostFix = "";

        switch(d.Bits){
            case 16:
                md.SubNamespace = ".HalfPrecision"; 
                md.SubDirectory = $"/HalfPrecision/{subFolder}";
                break;

            case 64: 
                md.SubNamespace = ".DoublePrecision"; 
                md.SubDirectory = $"/DoublePrecision/{subFolder}";
                break;

            case 128: 
                md.SubNamespace = ".QuadPrecision"; 
                md.SubDirectory = $"/QuadPrecision/{subFolder}";
                break;

            default:
                md.SubDirectory = $"/SinglePrecision/{subFolder}";
                break;
        }

        foreach(int size in sizes)
        {
            md.Size = size;

            if(filter != null && !filter(d, md))
                continue;

            md.Name = $"{d.Name}{size}{d.Postfix}";
            genEnvironment.Length = 0;

            callback(d, md, defs);

		    md.Filename = $"{md.Name}{md.FilePostFix}";

            SaveFile(outputPath + md.SubDirectory, md.Filename, genEnvironment.ToString());
		    genEnvironment.Length = 0;
        }
    }
}

public void SaveFile(string folder, string fileName, string content)
{
    string path = Path.Combine(folder, fileName.Trim() + ".cs");
    if(!Directory.Exists(folder))
        Directory.CreateDirectory(folder);

	using (FileStream fs = new FileStream(path, FileMode.Create))
    {
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
}

public List<T> ReadJsonDef<T>(string folder, string fileName) where T : class
{
    string json = File.ReadAllText(Path.Combine(folder, fileName.Trim()));
    return JsonConvert.DeserializeObject<List<T>>(json);
}

public string GetConstructorArgs(string type, string map, int count, string prefix = "", string postfix = "")
{
    if(map.Length < count)
        throw new Exception("Map length is shorter than count");
        
    string r = "";
    for(int i = 0; i < count; i++)
    {
        if(i > 0) r += ", ";
        r += $"{type} {prefix}{map[i]}{postfix}";
    }

    return r;
}

public string GetParamSentence(string pMap, int size, string delimiter = ", ", string finalDelimiter = "", string pPrefix = "", string pPostfix = "")
{
    string r = "";
    for(int i = 0; i < size; i++)
    {
        r += $"{pPrefix}{pMap[i]}{pPostfix}";
        r += i < (size - 1) ? (i < (size - 2) ? ", " : finalDelimiter) : ""; 
    }

    return r;
}

public string See(string typeName)
{
    return $"<see cref=\"{typeName}\"/>";
}
#>
