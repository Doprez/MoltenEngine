<#@ template debug="false" hostspecific="true" language="C#" #>

<#@ include file="t4_header.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

<#
TypeGenerator gen = new TypeGenerator(this.GenerationEnvironment, this.Host, "def_quaternions.json");

gen.Generate(null, (d, def) =>
{
    string vec2Name = d.Name.Replace("Quaternion", "Vector2");
    string vec3Name = d.Name.Replace("Quaternion", "Vector3");
    string vec4Name = d.Name.Replace("Quaternion", "Vector4");

    string mat3Name = d.Name.Replace("Quaternion", "Matrix3");
    string mat4Name = d.Name.Replace("Quaternion", "Matrix4");
#>
using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Molten<#=d.SubNamespace#>
{
	///<summary>Represents a four dimensional mathematical <#=d.Name#>.</summary>
	[StructLayout(LayoutKind.Sequential, Pack = <#=d.DT.Pack#>)]
    [Serializable]
	public partial struct <#=d.Name#> : IFormattable, IEquatable<<#=d.Name#>>
	{
		/// <summary>
        /// The size of the <#=gen.See()#> type, in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(typeof(<#=d.Name#>));

		 /// <summary>
        /// A <see cref="<#=d.Name#>"/> with all of its components set to zero.
        /// </summary>
        public static readonly <#=d.Name#> Zero = new <#=d.Name#>();

        /// <summary>
        /// A <see cref="<#=d.Name#>"/> with all of its components set to one.
        /// </summary>
        public static readonly <#=d.Name#> One = new <#=d.Name#>(<#=d.DT.One#>, <#=d.DT.One#>, <#=d.DT.One#>, <#=d.DT.One#>);

        /// <summary>
        /// The identity <see cref="<#=d.Name#>"/> (0, 0, 0, 1).
        /// </summary>
        public static readonly <#=d.Name#> Identity = new <#=d.Name#>(<#=d.DT.Zero#>, <#=d.DT.Zero#>, <#=d.DT.Zero#>, <#=d.DT.Zero#>);

<#=gen.GenerateFields()#>

        /// <summary>
        /// Gets a value indicting whether this  <see cref="<#=d.Name#>"/> is normalized.
        /// </summary>
        public bool IsNormalized => MathHelper.IsOne((X * X) + (Y * Y) + (Z * Z) + (W * W));

        /// <summary>
        /// Gets the angle of the  <see cref="<#=d.Name#>"/>.
        /// </summary>
        /// <value>The quaternion's angle.</value>
        public <#=d.DT#> Angle
        {
            get
            {
                <#=d.DT#> length = (X * X) + (Y * Y) + (Z * Z);
                if (MathHelper.IsZero(length))
                    return 0.0<#=d.FP.Literal#>;

                return 2.0<#=d.FP.Literal#> * <#=d.DT.Math#>.Acos(<#=d.DT#>.Clamp(W, -1<#=d.FP.Literal#>, 1<#=d.FP.Literal#>));
            }
        }

        /// <summary>
        /// Gets the axis components of the <#=d.Name#>.
        /// </summary>
        /// <value>The axis components of the <#=d.Name#>.</value>
        public <#=vec3Name#> Axis
        {
            get
            {
                <#=d.DT#> length = (X * X) + (Y * Y) + (Z * Z);
                if (MathHelper.IsZero(length))
                    return <#=vec3Name#>.UnitX;

                <#=d.DT#> inv = 1.0<#=d.FP.Literal#>  / <#=d.DT.Math#>.Sqrt(length);
                return new <#=vec3Name#>(X * inv, Y * inv, Z * inv);
            }
        }

#region Constructors
<#gen.GenerateStandardConstructors();#>
        /// <summary>
        /// Initializes a new instance of the <#=gen.See()#> struct.
        /// </summary>
        /// <param name="value">A <#=d.Name#> containing the values with which to initialize the components.</param>
        public <#=d.Name#>(<#=vec4Name#> value)
        {
            X = value.X;
            Y = value.Y;
            Z = value.Z;
            W = value.W;
        }

        /// <summary>
        /// Initializes a new instance of the <#=gen.See()#> struct.
        /// </summary>
        /// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
        /// <param name="w">Initial value for the W component of the <#=gen.See()#>.</param>
        public <#=d.Name#>(<#=vec3Name#> value, <#=d.DT#> w)
        {
            X = value.X;
            Y = value.Y;
            Z = value.Z;
            W = w;
        }

        /// <summary>
        /// Initializes a new instance of the <#=gen.See()#> struct.
        /// </summary>
        /// <param name="value">A vector containing the values with which to initialize the X and Y components.</param>
        /// <param name="z">Initial value for the Z component of the <#=gen.See()#>.</param>
        /// <param name="w">Initial value for the W component of the <#=gen.See()#>.</param>
        public <#=d.Name#>(<#=vec2Name#> value, <#=d.DT#> z, <#=d.DT#> w)
        {
            X = value.X;
            Y = value.Y;
            Z = z;
            W = w;
        }
#endregion

#region Instance Methods
/// <summary>
        /// Gets a value indicating whether this instance is equivalent to the identity <#=d.Name#>.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is an identity <#=d.Name#>; otherwise, <c>false</c>.
        /// </value>
        public bool IsIdentity
        {
            get { return this.Equals(Identity); }
        }

        /// <summary>
        /// Conjugates the <#=gen.See()#> X,Y and Z components. W component is not changed.
        /// </summary>
        public void Conjugate()
        {
            X = -X;
            Y = -Y;
            Z = -Z;
        }

        /// <summary>
        /// Conjugates the <#=gen.See()#>.
        /// </summary>
        public void Abs()
        {
            X = Math.Abs(X);
            Y = Math.Abs(Y);
            Z = Math.Abs(Z);
            W = Math.Abs(W);
        }

        /// <summary>
        /// Calculates the squared length of the <#=gen.See()#>.
        /// </summary>
        /// <returns>The squared length of the <#=gen.See()#>.</returns>
        /// <remarks>
        /// This method may be preferred to <see cref="<#=d.Name#>.Length"/> when only a relative length is needed
        /// and speed is of the essence.
        /// </remarks>
        public <#=d.DT#> LengthSquared()
        {
            return (X * X) + (Y * Y) + (Z * Z) + (W * W);
        }

        /// <summary>
        /// Creates an array containing the elements of the <#=gen.See()#>.
        /// </summary>
        /// <returns>A four-element array containing the components of the <#=gen.See()#>.</returns>
        public <#=d.DT#>[] ToArray()
        {
            return new <#=d.DT#>[] { X, Y, Z, W };
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
        /// </returns>
        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = X.GetHashCode();
                hashCode = (hashCode * 397) ^ Y.GetHashCode();
                hashCode = (hashCode * 397) ^ Z.GetHashCode();
                hashCode = (hashCode * 397) ^ W.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// Computes the quaternion rotation between two normalized vectors.
        /// </summary>
        /// <param name="v1">First unit-length vector.</param>
        /// <param name="v2">Second unit-length vector.</param>
        /// <param name="q">Quaternion representing the rotation from v1 to v2.</param>
        public static <#=d.Name#> GetQuaternionBetweenNormalizedVectors(ref <#=vec3Name#> v1, ref <#=vec3Name#> v2)
        {
            <#=d.Name#> q;
            <#=d.DT#> dot = <#=vec3Name#>.Dot(ref v1, ref v2);
            //For non-normal vectors, the multiplying the axes length squared would be necessary:
            //float w = dot + MathF.Sqrt(v1.LengthSquared() * v2.LengthSquared());
            if (dot < -0.9999<#=d.FP.Literal#>) //parallel, opposing direction
            {
                //If this occurs, the rotation required is ~180 degrees.
                //The problem is that we could choose any perpendicular axis for the rotation. It's not uniquely defined.
                //The solution is to pick an arbitrary perpendicular axis.
                //Project onto the plane which has the lowest component magnitude.
                //On that 2d plane, perform a 90 degree rotation.
                <#=d.DT#> absX = Math.Abs(v1.X);
                <#=d.DT#> absY = Math.Abs(v1.Y);
                <#=d.DT#> absZ = Math.Abs(v1.Z);
                if (absX < absY && absX < absZ)
                    q = new <#=d.Name#>(0, -v1.Z, v1.Y, 0);
                else if (absY < absZ)
                    q = new <#=d.Name#>(-v1.Z, 0, v1.X, 0);
                else
                    q = new <#=d.Name#>(-v1.Y, v1.X, 0, 0);
            }
            else
            {
                <#=vec3Name#> axis = <#=vec3Name#>.Cross(ref v1, ref v2);
                q = new <#=d.Name#>(axis.X, axis.Y, axis.Z, dot + 1);
            }
            q.Normalize();

            return q;
        }

        /// <summary>
        /// Converts the <#=gen.See()#> into a unit quaternion.
        /// </summary>
        public void Normalize()
        {
            <#=d.DT#> length = Length();
            if (!MathHelper.IsZero(length))
            {
                <#=d.DT#> inverse = 1.0<#=d.FP.Literal#> / length;
                X *= inverse;
                Y *= inverse;
                Z *= inverse;
                W *= inverse;
            }
        }

        /// <summary>
        /// Calculates the length of the <#=d.Name#>.
        /// </summary>
        /// <returns>The length of the <#=d.Name#>.</returns>
        /// <remarks>
        /// <see cref="<#=d.Name#>.LengthSquared"/> may be preferred when only the relative length is needed and speed is of the essence.
        /// </remarks>
        public <#=d.DT#> Length()
        {
            return <#=d.DT.FPCast#>Math.Sqrt((X * X) + (Y * Y) + (Z * Z) + (W * W));
        }

        /// <summary>
        /// Conjugates and renormalizes the <#=d.Name#>.
        /// </summary>
        public void Invert()
        {
            <#=d.DT#> lengthSq = LengthSquared();
            if (!MathHelper.IsZero(lengthSq))
            {
                lengthSq = 1.0<#=d.FP.Literal#> / lengthSq;

                X = -X * lengthSq;
                Y = -Y * lengthSq;
                Z = -Z * lengthSq;
                W = W * lengthSq;
            }
        }

        /// <summary>
        /// Determines whether the specified <#=gen.See()#> is equal to this instance.
        /// </summary>
        /// <param name="other">The <#=gen.See()#> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <#=gen.See()#> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(ref <#=d.Name#> other)
        {
            return MathHelper.NearEqual(other.X, X) && MathHelper.NearEqual(other.Y, Y) && MathHelper.NearEqual(other.Z, Z) && MathHelper.NearEqual(other.W, W);
        }

        /// <summary>
        /// Determines whether the specified <#=gen.See()#> is equal to this instance.
        /// </summary>
        /// <param name="other">The <#=gen.See()#> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <#=gen.See()#> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=d.Name#> other)
        {
            return Equals(ref other);
        }

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="value">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object value)
        {
            if (!(value is <#=d.Name#>))
                return false;

            var strongValue = (<#=d.Name#>)value;
            return Equals(ref strongValue);
        }
#endregion

#region To-String Methods
/// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "X:{0} Y:{1} Z:{2} W:{3}", X, Y, Z, W);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(string format)
        {
            if (format == null)
                return ToString();

            return string.Format(CultureInfo.CurrentCulture, "X:{0} Y:{1} Z:{2} W:{3}", X.ToString(format, CultureInfo.CurrentCulture),
                Y.ToString(format, CultureInfo.CurrentCulture), Z.ToString(format, CultureInfo.CurrentCulture), W.ToString(format, CultureInfo.CurrentCulture));
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(IFormatProvider formatProvider)
        {
            return string.Format(formatProvider, "X:{0} Y:{1} Z:{2} W:{3}", X, Y, Z, W);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
                return ToString(formatProvider);

            return string.Format(formatProvider, "X:{0} Y:{1} Z:{2} W:{3}", X.ToString(format, formatProvider),
                Y.ToString(format, formatProvider), Z.ToString(format, formatProvider), W.ToString(format, formatProvider));
        }
#endregion

#region Static Methods
        /// <summary>
        /// Multiplies two <#=gen.See()#> together in opposite order.
        /// </summary>
        /// <param name="a">First <#=gen.See()#> to multiply.</param>
        /// <param name="b">Second <#=gen.See()#> to multiply.</param>
        public static void Concatenate(ref <#=d.Name#> a, ref <#=d.Name#> b, out <#=d.Name#> result)
        {
            <#=d.DT#> aX = a.X;
            <#=d.DT#> aY = a.Y;
            <#=d.DT#> aZ = a.Z;
            <#=d.DT#> aW = a.W;
            <#=d.DT#> bX = b.X;
            <#=d.DT#> bY = b.Y;
            <#=d.DT#> bZ = b.Z;
            <#=d.DT#> bW = b.W;

            result.X = aW * bX + aX * bW + aZ * bY - aY * bZ;
            result.Y = aW * bY + aY * bW + aX * bZ - aZ * bX;
            result.Z = aW * bZ + aZ * bW + aY * bX - aX * bY;
            result.W = aW * bW - aX * bX - aY * bY - aZ * bZ;
        }

        /// <summary>
        /// Multiplies two <#=gen.See()#> together in opposite order.
        /// </summary>
        /// <param name="a">First <#=gen.See()#> to multiply.</param>
        /// <param name="b">Second <#=gen.See()#> to multiply.</param>
        public static <#=d.Name#> Concatenate(ref <#=d.Name#> a, ref <#=d.Name#> b)
        {
            Concatenate(ref a, ref b, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Computes the angle change represented by a normalized quaternion.
        /// </summary>
        /// <param name="q">Quaternion to be converted.</param>
        /// <returns>Angle around the axis represented by the quaternion.</returns>
        public static <#=d.DT#> GetAngleFromQuaternion(ref <#=d.Name#> q)
        {
            <#=d.DT#> qw = Math.Abs(q.W);
            if (qw > 1)
                return 0;
            return 2 * (<#=d.DT#>)Math.Acos(qw);
        }

        /// <summary>
        /// Calculates the natural logarithm of the specified quaternion.
        /// </summary>
        /// <param name="value">The quaternion whose logarithm will be calculated.</param>
        /// <param name="result">When the method completes, contains the natural logarithm of the quaternion.</param>
        public static <#=d.Name#> Logarithm(ref <#=d.Name#> value)
        {
            <#=d.Name#> result;

            if (Math.Abs(value.W) < 1.0)
            {
                <#=d.DT#> angle = <#=d.DT.FPCast#>Math.Acos(value.W);
                <#=d.DT#> sin = <#=d.DT.FPCast#>Math.Sin(angle);

                if (!MathHelper.IsZero(sin))
                {
                    <#=d.DT#> coeff = angle / sin;
                    result.X = value.X * coeff;
                    result.Y = value.Y * coeff;
                    result.Z = value.Z * coeff;
                }
                else
                {
                    result = value;
                }
            }
            else
            {
                result = value;
            }

            result.W = 0.0<#=d.FP.Literal#>;
            return result;
        }

        /// <summary>
        /// Calculates the natural logarithm of the specified quaternion.
        /// </summary>
        /// <param name="value">The quaternion whose logarithm will be calculated.</param>
        /// <param name="result">When the method completes, contains the natural logarithm of the quaternion.</param>
        public static <#=d.Name#> Logarithm(<#=d.Name#> value)
        {
            return Logarithm(ref value);
        }

        /// <summary>
        /// Computes the axis angle representation of a normalized <#=gen.See()#>.
        /// </summary>
        /// <param name="q"><#=gen.See()#> to be converted.</param>
        /// <param name="axis">Axis represented by the <#=gen.See()#>.</param>
        /// <param name="angle">Angle around the axis represented by the <#=gen.See()#>.</param>
        public static void GetAxisAngle(ref <#=d.Name#> q, out <#=vec3Name#> axis, out <#=d.DT#> angle)
        {
            <#=d.DT#> qw = q.W;
            if (qw > 0)
            {
                axis.X = q.X;
                axis.Y = q.Y;
                axis.Z = q.Z;
            }
            else
            {
                axis.X = -q.X;
                axis.Y = -q.Y;
                axis.Z = -q.Z;
                qw = -qw;
            }

            <#=d.DT#> lengthSquared = axis.LengthSquared();
            if (lengthSquared > 1e-14f)
            {
                axis = axis / <#=d.DT.Math#>.Sqrt(lengthSquared);
                angle = 2<#=d.FP.Literal#> * <#=d.DT.Math#>.Acos(<#=d.DT#>.Clamp(qw, -1, 1));
            }
            else
            {
                axis = <#=vec3Name#>.Up;
                angle = 0;
            }
        }

        /// <summary>
        /// Sets up control points for spherical quadrangle interpolation.
        /// </summary>
        /// <param name="value1">First source <#=gen.See()#>.</param>
        /// <param name="value2">Second source <#=gen.See()#>.</param>
        /// <param name="value3">Third source <#=gen.See()#>.</param>
        /// <param name="value4">Fourth source <#=gen.See()#>.</param>
        /// <returns>An array of three <#=gen.See()#> that represent control points for spherical quadrangle interpolation.</returns>
        public static <#=d.Name#>[] SquadSetup(ref <#=d.Name#> value1, ref <#=d.Name#> value2, ref <#=d.Name#> value3, ref <#=d.Name#> value4)
        {
            <#=d.Name#> q0 = (value1 + value2).LengthSquared() < (value1 - value2).LengthSquared() ? -value1 : value1;
            <#=d.Name#> q2 = (value2 + value3).LengthSquared() < (value2 - value3).LengthSquared() ? -value3 : value3;
            <#=d.Name#> q3 = (value3 + value4).LengthSquared() < (value3 - value4).LengthSquared() ? -value4 : value4;
            <#=d.Name#> q1 = value2;

            <#=d.Name#> q1Exp = Exponential(ref q1);
            <#=d.Name#> q2Exp = Exponential(ref q2);

            <#=d.Name#>[] results = new <#=d.Name#>[3];
            results[0] = q1 * Exponential(-0.25f * (Logarithm(q1Exp * q2) + Logarithm(q1Exp * q0)));
            results[1] = q2 * Exponential(-0.25f * (Logarithm(q2Exp * q3) + Logarithm(q2Exp * q1)));
            results[2] = q2;

            return results;
        }

        /// <summary>
        /// Interpolates between <#=gen.See()#>, using spherical quadrangle interpolation.
        /// </summary>
        /// <param name="value1">First source <#=gen.See()#>.</param>
        /// <param name="value2">Second source <#=gen.See()#>.</param>
        /// <param name="value3">Third source <#=gen.See()#>.</param>
        /// <param name="value4">Fourth source <#=gen.See()#>.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
        /// <param name="result">When the method completes, contains the spherical quadrangle interpolation of the <#=gen.See()#>.</param>
        public static <#=d.Name#> Squad(ref <#=d.Name#> value1, ref <#=d.Name#> value2, ref <#=d.Name#> value3, ref <#=d.Name#> value4, float amount)
        {
            <#=d.Name#> start = Slerp(ref value1, ref value4, amount);
            <#=d.Name#> end = Slerp(ref value2, ref value3, amount);
            return Slerp(ref start, ref end, 2.0<#=d.FP.Literal#> * amount * (1.0<#=d.FP.Literal#> - amount));
        }

        /// <summary>
        /// Interpolates between two <#=gen.See()#>, using spherical linear interpolation.
        /// </summary>
        /// <param name="start">Start <#=gen.See()#>.</param>
        /// <param name="end">End <#=gen.See()#>.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <param name="result">When the method completes, contains the spherical linear interpolation of the two <#=gen.See()#>.</param>
        public static <#=d.Name#> Slerp(ref <#=d.Name#> start, ref <#=d.Name#> end, <#=d.DT#> amount)
        {
            <#=d.DT#> opposite;
            <#=d.DT#> inverse;
            <#=d.DT#> dot = Dot(start, end);

            if (<#=d.DT.Math#>.Abs(dot) > 1.0<#=d.FP.Literal#> - MathHelper.Constants<<#=d.DT#>>.ZeroTolerance)
            {
                inverse = 1.0<#=d.FP.Literal#> - amount;
                opposite = amount * <#=d.DT.Math#>.Sign(dot);
            }
            else
            {
                <#=d.DT#> acos = <#=d.DT.Math#>.Acos(Math.Abs(dot));
                <#=d.DT#> invSin = 1.0<#=d.FP.Literal#> / <#=d.DT.Math#>.Sin(acos);

                inverse = <#=d.DT.Math#>.Sin((1.0<#=d.FP.Literal#> - amount) * acos) * invSin;
                opposite = <#=d.DT.Math#>.Sin(amount * acos) * invSin * Math.Sign(dot);
            }

            return new <#=d.Name#>()
            {
                X = (inverse * start.X) + (opposite * end.X),
                Y = (inverse * start.Y) + (opposite * end.Y),
                Z = (inverse * start.Z) + (opposite * end.Z),
                W = (inverse * start.W) + (opposite * end.W)
            };
        }

        /// <summary>
        /// Creates a quaternion given a yaw, pitch, and roll value.
        /// </summary>
        /// <param name="yaw">The yaw of rotation.</param>
        /// <param name="pitch">The pitch of rotation.</param>
        /// <param name="roll">The roll of rotation.</param>
        public static void RotationYawPitchRoll(<#=d.DT#> yaw, <#=d.DT#> pitch, <#=d.DT#> roll, out <#=d.Name#> result)
        {
            <#=d.DT#> halfRoll = roll * 0.5f;
            <#=d.DT#> halfPitch = pitch * 0.5f;
            <#=d.DT#> halfYaw = yaw * 0.5f;

            <#=d.DT#> sinRoll = <#=d.DT.FPCast#>Math.Sin(halfRoll);
            <#=d.DT#> cosRoll = <#=d.DT.FPCast#>Math.Cos(halfRoll);
            <#=d.DT#> sinPitch = <#=d.DT.FPCast#>Math.Sin(halfPitch);
            <#=d.DT#> cosPitch = <#=d.DT.FPCast#>Math.Cos(halfPitch);
            <#=d.DT#> sinYaw = <#=d.DT.FPCast#>Math.Sin(halfYaw);
            <#=d.DT#> cosYaw = <#=d.DT.FPCast#>Math.Cos(halfYaw);

            result.X = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.Y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.Z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.W = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }

        /// <summary>
        /// Creates a quaternion given a yaw, pitch, and roll value.
        /// </summary>
        /// <param name="yaw">The yaw of rotation.</param>
        /// <param name="pitch">The pitch of rotation.</param>
        /// <param name="roll">The roll of rotation.</param>
        public static <#=d.Name#> RotationYawPitchRoll(<#=d.DT#> yaw, <#=d.DT#> pitch, <#=d.DT#> roll)
        {
            <#=d.DT#> halfRoll = roll * 0.5f;
            <#=d.DT#> halfPitch = pitch * 0.5f;
            <#=d.DT#> halfYaw = yaw * 0.5f;

            <#=d.DT#> sinRoll = <#=d.DT.FPCast#>Math.Sin(halfRoll);
            <#=d.DT#> cosRoll = <#=d.DT.FPCast#>Math.Cos(halfRoll);
            <#=d.DT#> sinPitch = <#=d.DT.FPCast#>Math.Sin(halfPitch);
            <#=d.DT#> cosPitch = <#=d.DT.FPCast#>Math.Cos(halfPitch);
            <#=d.DT#> sinYaw = <#=d.DT.FPCast#>Math.Sin(halfYaw);
            <#=d.DT#> cosYaw = <#=d.DT.FPCast#>Math.Cos(halfYaw);

            return new <#=d.Name#>()
            {
                X = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll),
                Y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll),
                Z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll),
                W = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll)
            };
        }

        /// <summary>
        /// Creates a <#=gen.See()#> given a rotation matrix.
        /// </summary>
        /// <param name="matrix">The rotation matrix.</param>
        public static <#=d.Name#> FromRotationMatrix(ref <#=mat4Name#> matrix)
        {
            <#=d.DT#> sqrt;
            <#=d.DT#> half;
            <#=d.DT#> scale = matrix.M11 + matrix.M22 + matrix.M33;
            <#=d.Name#> result;

            if (scale > 0.0<#=d.FP.Literal#>)
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(scale + 1.0<#=d.FP.Literal#>);
                result.W = sqrt * 0.5<#=d.FP.Literal#>;
                sqrt = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = (matrix.M23 - matrix.M32) * sqrt;
                result.Y = (matrix.M31 - matrix.M13) * sqrt;
                result.Z = (matrix.M12 - matrix.M21) * sqrt;
            }
            else if ((matrix.M11 >= matrix.M22) && (matrix.M11 >= matrix.M33))
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0<#=d.FP.Literal#> + matrix.M11 - matrix.M22 - matrix.M33);
                half = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = 0.5<#=d.FP.Literal#> * sqrt;
                result.Y = (matrix.M12 + matrix.M21) * half;
                result.Z = (matrix.M13 + matrix.M31) * half;
                result.W = (matrix.M23 - matrix.M32) * half;
            }
            else if (matrix.M22 > matrix.M33)
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0<#=d.FP.Literal#> + matrix.M22 - matrix.M11 - matrix.M33);
                half = 0.5f / sqrt;

                result.X = (matrix.M21 + matrix.M12) * half;
                result.Y = 0.5<#=d.FP.Literal#> * sqrt;
                result.Z = (matrix.M32 + matrix.M23) * half;
                result.W = (matrix.M31 - matrix.M13) * half;
            }
            else
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0<#=d.FP.Literal#>  + matrix.M33 - matrix.M11 - matrix.M22);
                half = 0.5<#=d.FP.Literal#>  / sqrt;

                result.X = (matrix.M31 + matrix.M13) * half;
                result.Y = (matrix.M32 + matrix.M23) * half;
                result.Z = 0.5<#=d.FP.Literal#> * sqrt;
                result.W = (matrix.M12 - matrix.M21) * half;
            }

            return result;
        }

        /// <summary>
        /// Creates a quaternion given a rotation matrix.
        /// </summary>
        /// <param name="matrix">The rotation matrix.</param>
        public static <#=d.Name#> FromRotationMatrix(ref <#=mat3Name#> matrix)
        {
            <#=d.DT#> sqrt;
            <#=d.DT#> half;
            <#=d.DT#> scale = matrix.M11 + matrix.M22 + matrix.M33;
            <#=d.Name#> result;

            if (scale > 0.0f)
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(scale + 1.0f);
                result.W = sqrt * 0.5<#=d.FP.Literal#>;
                sqrt = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = (matrix.M23 - matrix.M32) * sqrt;
                result.Y = (matrix.M31 - matrix.M13) * sqrt;
                result.Z = (matrix.M12 - matrix.M21) * sqrt;
            }
            else if ((matrix.M11 >= matrix.M22) && (matrix.M11 >= matrix.M33))
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0f + matrix.M11 - matrix.M22 - matrix.M33);
                half = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = 0.5<#=d.FP.Literal#> * sqrt;
                result.Y = (matrix.M12 + matrix.M21) * half;
                result.Z = (matrix.M13 + matrix.M31) * half;
                result.W = (matrix.M23 - matrix.M32) * half;
            }
            else if (matrix.M22 > matrix.M33)
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0f + matrix.M22 - matrix.M11 - matrix.M33);
                half = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = (matrix.M21 + matrix.M12) * half;
                result.Y = 0.5<#=d.FP.Literal#> * sqrt;
                result.Z = (matrix.M32 + matrix.M23) * half;
                result.W = (matrix.M31 - matrix.M13) * half;
            }
            else
            {
                sqrt = <#=d.DT.FPCast#>Math.Sqrt(1.0f + matrix.M33 - matrix.M11 - matrix.M22);
                half = 0.5<#=d.FP.Literal#> / sqrt;

                result.X = (matrix.M31 + matrix.M13) * half;
                result.Y = (matrix.M32 + matrix.M23) * half;
                result.Z = 0.5<#=d.FP.Literal#> * sqrt;
                result.W = (matrix.M12 - matrix.M21) * half;
            }

            return result;
        }

        /// <summary>
        /// Calculates the dot product of two quaternions.
        /// </summary>
        /// <param name="left">First source quaternion.</param>
        /// <param name="right">Second source quaternion.</param>
        public static float Dot(ref QuaternionF left, ref QuaternionF right)
        {
            return (left.X * right.X) + (left.Y * right.Y) + (left.Z * right.Z) + (left.W * right.W);
        }

        /// <summary>
        /// Calculates the dot product of two <#=gen.See()#>.
        /// </summary>
        /// <param name="left">First source <#=gen.See()#>.</param>
        /// <param name="right">Second source <#=gen.See()#>.</param>
        /// <returns>The dot product of the two <#=gen.See()#>.</returns>
        public static <#=d.DT#> Dot(<#=d.Name#> left, <#=d.Name#> right)
        {
            return (left.X * right.X) + (left.Y * right.Y) + (left.Z * right.Z) + (left.W * right.W);
        }

        /// <summary>
        /// Exponentiates a <#=gen.See()#>.
        /// </summary>
        /// <param name="value">The <#=gen.See()#> to exponentiate.</param>
        public static <#=d.Name#> Exponential(ref <#=d.Name#> value)
        {
            <#=d.DT#> angle = <#=d.DT#>.Sqrt((value.X * value.X) + (value.Y * value.Y) + (value.Z * value.Z));
            <#=d.DT#> sin = <#=d.DT#>.Sin(angle);
            <#=d.Name#> result;

            if (!MathHelper.IsZero(sin))
            {
                <#=d.DT#> coeff = sin / angle;
                result.X = coeff * value.X;
                result.Y = coeff * value.Y;
                result.Z = coeff * value.Z;
            }
            else
            {
                result = value;
            }

            result.W = <#=d.DT#>.Cos(angle);
            return result;
        }

        /// <summary>
        /// Exponentiates a <#=gen.See()#>.
        /// </summary>
        /// <param name="value">The <#=gen.See()#> to exponentiate.</param>
        public static <#=d.Name#> Exponential(<#=d.Name#> value)
        {
            return Exponential(ref value);
        }

        /// <summary>
        /// Returns a <#=gen.See()#> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
        /// </summary>
        /// <param name="value1">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
        /// <param name="value2">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
        /// <param name="value3">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
        /// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
        /// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
        public static <#=d.Name#> Barycentric(ref <#=d.Name#> value1, ref <#=d.Name#> value2, ref <#=d.Name#> value3, <#=d.DT#> amount1, <#=d.DT#> amount2)
        {
            <#=d.Name#> start = Slerp(ref value1, ref value2, amount1 + amount2);
            <#=d.Name#> end = Slerp(ref value1, ref value3, amount1 + amount2);
            return Slerp(ref start, ref end, amount2 / (amount1 + amount2));
        }

        /// <summary>
        /// Returns a <#=gen.See()#> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
        /// </summary>
        /// <param name="value1">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
        /// <param name="value2">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
        /// <param name="value3">A <#=gen.See()#> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
        /// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
        /// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
        public static <#=d.Name#> Barycentric(<#=d.Name#> value1, <#=d.Name#> value2, <#=d.Name#> value3, <#=d.DT#> amount1, <#=d.DT#> amount2)
        {
            return Barycentric(ref value1, ref value2, ref value3, amount1, amount2);
        }

        /// <summary>
        /// Computes the conjugate of the <#=gen.See()#> .
        /// </summary>
        /// <param name="value"><#=gen.See()#> to conjugate.</param>
        public static <#=d.Name#> Conjugate(ref <#=d.Name#> value)
        {
            return new <#=d.Name#>()
            {
                X = -value.X,
                Y = -value.Y,
                Z = -value.Z,
                W = value.W
            };
        }

        /// <summary>
        /// Computes the conjugate of the <#=gen.See()#> .
        /// </summary>
        /// <param name="value"><#=gen.See()#> to conjugate.</param>
        public static void Conjugate(ref <#=d.Name#> value, out <#=d.Name#> result)
        {
            result.X = -value.X;
            result.Y = -value.Y;
            result.Z = -value.Z;
            result.W = value.W;
        }

        /// <summary>
        /// Computes the conjugate of the <#=gen.See()#> .
        /// </summary>
        /// <param name="value"><#=gen.See()#> to conjugate.</param>
        public static <#=d.Name#> Conjugate(<#=d.Name#> value)
        {
            return new <#=d.Name#>()
            {
                X = -value.X,
                Y = -value.Y,
                Z = -value.Z,
                W = value.W
            };
        }

        /// <summary>
        /// Performs a linear interpolation between two <#=gen.See()#>.
        /// </summary>
        /// <param name="start">Start <#=gen.See()#>.</param>
        /// <param name="end">End <#=gen.See()#>.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <remarks>
        /// This method performs the linear interpolation based on the following formula.
        /// <code>start + (end - start) * amount</code>
        /// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
        /// </remarks>
        public static <#=d.Name#> Lerp(ref <#=d.Name#> start, ref <#=d.Name#> end, <#=d.DT#> amount)
        {
            <#=d.DT#> inverse = 1.0<#=d.FP.Literal#> - amount;
            <#=d.Name#> result;

            if (Dot(start, end) >= 0.0<#=d.FP.Literal#>)
            {
                result.X = (inverse * start.X) + (amount * end.X);
                result.Y = (inverse * start.Y) + (amount * end.Y);
                result.Z = (inverse * start.Z) + (amount * end.Z);
                result.W = (inverse * start.W) + (amount * end.W);
            }
            else
            {
                result.X = (inverse * start.X) - (amount * end.X);
                result.Y = (inverse * start.Y) - (amount * end.Y);
                result.Z = (inverse * start.Z) - (amount * end.Z);
                result.W = (inverse * start.W) - (amount * end.W);
            }

            result.Normalize();
            return result;
        }

        /// <summary>
        /// Creates a <#=gen.See()#> given a rotation and an axis.
        /// </summary>
        /// <param name="axis">The axis of rotation.</param>
        /// <param name="angle">The angle of rotation.</param>
        public static <#=d.Name#> FromAxisAngle(<#=vec3Name#> axis, float angle)
        {
            return FromAxisAngle(ref axis, angle);
        }

        /// <summary>
        /// Creates a <#=gen.See()#> given a rotation and an axis.
        /// </summary>
        /// <param name="axis">The axis of rotation.</param>
        /// <param name="angle">The angle of rotation.</param>
        public static <#=d.Name#> FromAxisAngle(ref <#=vec3Name#> axis, float angle)
        {
            <#=vec3Name#> normalized = axis.GetNormalized();

            <#=d.DT#> half = angle * 0.5<#=d.FP.Literal#>;
            <#=d.DT#> sin = <#=d.DT.FPCast#>Math.Sin(half);
            <#=d.DT#> cos = <#=d.DT.FPCast#>Math.Cos(half);

            return new <#=d.Name#>()
            {
                X = normalized.X * sin,
                Y = normalized.Y * sin,
                Z = normalized.Z * sin,
                W = cos     
            };
        }

        /// <summary>
        /// Creates a left-handed, look-at <#=gen.See()#>.
        /// </summary>
        /// <param name="eye">The position of the viewer's eye.</param>
        /// <param name="target">The camera look-at target.</param>
        /// <param name="up">The camera's up vector.</param>
        public static <#=d.Name#> LookAtLH(ref <#=vec3Name#> eye, ref <#=vec3Name#> target, ref <#=vec3Name#> up)
        {
            <#=mat3Name#> matrix = <#=mat3Name#>.LookAtLH(ref eye, ref target, ref up);
            return FromRotationMatrix(ref matrix);
        }

        /// <summary>
        /// Creates a left-handed, look-at quaternion.
        /// </summary>
        /// <param name="forward">The camera's forward direction.</param>
        /// <param name="up">The camera's up vector.</param>
        /// <returns>The created look-at quaternion.</returns>
        public static <#=d.Name#> RotationLookAtLH(<#=vec3Name#> forward, <#=vec3Name#> up)
        {
            return RotationLookAtLH(ref forward, ref up);
        }

        /// <summary>
        /// Creates a left-handed, look-at <#=gen.See()#>.
        /// </summary>
        /// <param name="forward">The camera's forward direction.</param>
        /// <param name="up">The camera's up vector.</param>
        public static <#=d.Name#>  RotationLookAtLH(ref <#=vec3Name#> forward, ref <#=vec3Name#> up)
        {
            <#=vec3Name#> eye = <#=vec3Name#>.Zero;
            return LookAtLH(ref eye, ref forward, ref up);
        }

        /// <summary>
        /// Creates a right-handed, look-at quaternion.
        /// </summary>
        /// <param name="eye">The position of the viewer's eye.</param>
        /// <param name="target">The camera look-at target.</param>
        /// <param name="up">The camera's up vector.</param>
        public static <#=d.Name#> LookAtRH(ref <#=vec3Name#> eye, ref <#=vec3Name#> target, ref <#=vec3Name#> up)
        {
            <#=mat3Name#> matrix = <#=mat3Name#>.LookAtRH(ref eye, ref target, ref up);
            return FromRotationMatrix(ref matrix);
        }

        /// <summary>
        /// Creates a right-handed, look-at quaternion.
        /// </summary>
        /// <param name="forward">The camera's forward direction.</param>
        /// <param name="up">The camera's up vector.</param>
        public static <#=d.Name#> RotationLookAtRH(ref <#=vec3Name#> forward, ref <#=vec3Name#> up)
        {
            <#=vec3Name#> eye = <#=vec3Name#>.Zero;
            return LookAtRH(ref eye, ref forward, ref up);
        }

        /// <summary>
        /// Creates a left-handed spherical billboard that rotates around a specified object position.
        /// </summary>
        /// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
        /// <param name="cameraPosition">The position of the camera.</param>
        /// <param name="cameraUpVector">The up vector of the camera.</param>
        /// <param name="cameraForwardVector">The forward vector of the camera.</param>
        public static <#=d.Name#> BillboardLH(ref <#=vec3Name#> objectPosition, ref <#=vec3Name#> cameraPosition, ref <#=vec3Name#> cameraUpVector, ref <#=vec3Name#> cameraForwardVector)
        {
            <#=mat3Name#> matrix = <#=mat3Name#>.BillboardLH(ref objectPosition, ref cameraPosition, ref cameraUpVector, ref cameraForwardVector);
            return FromRotationMatrix(ref matrix);
        }

        /// <summary>
        /// Creates a right-handed spherical billboard that rotates around a specified object position.
        /// </summary>
        /// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
        /// <param name="cameraPosition">The position of the camera.</param>
        /// <param name="cameraUpVector">The up vector of the camera.</param>
        /// <param name="cameraForwardVector">The forward vector of the camera.</param>
        public static <#=d.Name#> BillboardRH(ref <#=vec3Name#> objectPosition, ref <#=vec3Name#> cameraPosition, ref <#=vec3Name#> cameraUpVector, ref <#=vec3Name#> cameraForwardVector)
        {
            <#=mat3Name#> matrix = <#=mat3Name#>.BillboardRH(ref objectPosition, ref cameraPosition, ref cameraUpVector, ref cameraForwardVector);
            return FromRotationMatrix(ref matrix);
        }
#endregion

#region Operators - Multiply
        /// <summary>
        /// Scales a quaternion by the given value.
        /// </summary>
        /// <param name="value">The quaternion to scale.</param>
        /// <param name="scale">The amount by which to scale the quaternion.</param>
        /// <returns>The scaled quaternion.</returns>
        public static <#=d.Name#> operator *(<#=d.DT#> scale, <#=d.Name#> value)
        {
            return new <#=d.Name#>()
            {
                X = value.X * scale,
                Y = value.Y * scale,
                Z = value.Z * scale,
                W = value.W * scale,
            };
        }

        /// <summary>
        /// Scales a quaternion by the given value.
        /// </summary>
        /// <param name="value">The quaternion to scale.</param>
        /// <param name="scale">The amount by which to scale the quaternion.</param>
        /// <returns>The scaled quaternion.</returns>
        public static <#=d.Name#> operator *(<#=d.Name#> value, <#=d.DT#> scale)
        {
            return new <#=d.Name#>()
            {
                X = value.X * scale,
                Y = value.Y * scale,
                Z = value.Z * scale,
                W = value.W * scale,
            };
        }

        /// <summary>
        /// Multiplies a <#=d.Name#> by another <#=d.Name#>.
        /// </summary>
        /// <param name="left">A reference to the first <#=d.Name#> to multiply.</param>
        /// <param name="right">A reference to the second <#=d.Name#> to multiply.</param>
        /// <param name="result">An output to store the result.</param>
        /// <returns>The multiplied <#=d.Name#>.</returns>
        public static void Multiply(ref <#=d.Name#> left, ref <#=d.Name#> right, out <#=d.Name#> result)
        {
            <#=d.DT#> lx = left.X;
            <#=d.DT#> ly = left.Y;
            <#=d.DT#> lz = left.Z;
            <#=d.DT#> lw = left.W;
            <#=d.DT#> rx = right.X;
            <#=d.DT#> ry = right.Y;
            <#=d.DT#> rz = right.Z;
            <#=d.DT#> rw = right.W;
            <#=d.DT#> a = (ly * rz - lz * ry);
            <#=d.DT#> b = (lz * rx - lx * rz);
            <#=d.DT#> c = (lx * ry - ly * rx);
            <#=d.DT#> d = (lx * rx + ly * ry + lz * rz);

            result.X = (lx * rw + rx * lw) + a;
            result.Y = (ly * rw + ry * lw) + b;
            result.Z = (lz * rw + rz * lw) + c;
            result.W = lw * rw - d;
        }

        /// <summary>
        /// Multiplies a <#=d.Name#> by another <#=d.Name#>.
        /// </summary>
        /// <param name="left">The first <#=d.Name#> to multiply.</param>
        /// <param name="right">The second <#=d.Name#> to multiply.</param>
        /// <returns>The multiplied <#=d.Name#>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=d.Name#> operator *(<#=d.Name#> left, <#=d.Name#> right)
        {
            Multiply(ref left, ref right, out <#=d.Name#> result);
            return result;
        }
#endregion

#region Operators - Subtract
<#gen.GenerateOperator("-", "Subtract");#>

        /// <summary>
        /// Reverses the direction of a given quaternion.
        /// </summary>
        /// <param name="value">The quaternion to negate.</param>
        /// <returns>A quaternion facing in the opposite direction.</returns>
        public static <#=d.Name#> operator -(<#=d.Name#> value)
        {
            return new <#=d.Name#>()
            {
                X = -value.X,
                Y = -value.Y,
                Z = -value.Z,
                W = -value.W
            };
        }
#endregion

#region Operators - Division
<#gen.GenerateOperator("/", "Division");#>
#endregion

#region Operators - Add
<#gen.GenerateOperator("+", "Add");#>
#endregion

#region Operators - Equality
/// <summary>
        /// Tests for equality between two objects.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#=d.Name#> left, <#=d.Name#> right)
        {
            return left.Equals(ref right);
        }

        /// <summary>
        /// Tests for inequality between two objects.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#=d.Name#> left, <#=d.Name#> right)
        {
            return !left.Equals(ref right);
        }
#endregion

#region Indexers
/// <summary>
        /// Gets or sets the component at the specified index.
        /// </summary>
        /// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
        /// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
        /// <returns>The value of the component at the specified index.</returns>
        /// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
        public <#=d.DT#> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    case 2: return Z;
                    case 3: return W;
                }

                throw new ArgumentOutOfRangeException("index", "Indices for <#=d.Name#> run from 0 to 3, inclusive.");
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    case 2: Z = value; break;
                    case 3: W = value; break;
                    default: throw new ArgumentOutOfRangeException("index", "Indices for <#=d.Name#> run from 0 to 3, inclusive.");
                }
            }
        }
#endregion
	}
}
<#
});
#>
