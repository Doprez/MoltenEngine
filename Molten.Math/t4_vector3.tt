<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="t4_header.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#
string pMap = "xyzw";
string pMapUpper = "XYZW";

GenerateTypes(this.GenerationEnvironment, this.Host, "Vectors", "vector_defs.json", "v3", _vectorSizes, (d,md) => md.Size == 3, (d, md, defs) =>
{
#>
using System.Runtime.InteropServices;

namespace Molten<#=md.SubNamespace#>
{
	///<summary>A <see cref = "<#=d.DT#>"/> vector comprised of <#=md.Size#> components.</summary>
	public partial struct <#=md.Name#>
	{
<#
    if(!d.Unsigned)
    {
#>
           /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating up (0, 1, 0).
        /// </summary>
        public static readonly <#=md.Name#> Up = new <#=md.Name#>(<#=d.Zero#>, <#=d.One#>, <#=d.Zero#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating down (0, -1, 0).
        /// </summary>
        public static readonly <#=md.Name#> Down = new <#=md.Name#>(<#=d.Zero#>, -<#=d.One#>, <#=d.Zero#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating left (-1, 0, 0).
        /// </summary>
        public static readonly <#=md.Name#> Left = new <#=md.Name#>(-<#=d.One#>, <#=d.Zero#>, <#=d.Zero#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating right (1, 0, 0).
        /// </summary>
        public static readonly <#=md.Name#> Right = new <#=md.Name#>(<#=d.One#>, <#=d.Zero#>, <#=d.Zero#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating forward in a right-handed coordinate system (0, 0, -1).
        /// </summary>
        public static readonly <#=md.Name#> ForwardRH = new <#=md.Name#>(<#=d.Zero#>, <#=d.Zero#>, -<#=d.One#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating forward in a left-handed coordinate system (0, 0, 1).
        /// </summary>
        public static readonly <#=md.Name#> ForwardLH = new <#=md.Name#>(<#=d.Zero#>, <#=d.Zero#>, <#=d.One#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating backward in a right-handed coordinate system (0, 0, 1).
        /// </summary>
        public static readonly <#=md.Name#> BackwardRH = new <#=md.Name#>(<#=d.Zero#>, <#=d.Zero#>, <#=d.One#>);

        /// <summary>
        /// A unit <see cref="<#=md.Name#>"/> designating backward in a left-handed coordinate system (0, 0, -1).
        /// </summary>
        public static readonly <#=md.Name#> BackwardLH = new <#=md.Name#>(<#=d.Zero#>, <#=d.Zero#>, -<#=d.One#>);
<#
    }
#>

#region Static Methods
        /// <summary>
        /// Calculates the cross product of two <#=See(md.Name)#>.
        /// </summary>
        /// <param name="left">First source <#=See(md.Name)#>.</param>
        /// <param name="right">Second source <#=See(md.Name)#>.</param>

        public static void Cross(ref <#=md.Name#> left, ref <#=md.Name#> right, out <#=md.Name#> result)
        {
                result.X = <#=md.TypeCast#>((left.Y * right.Z) - (left.Z * right.Y));
                result.Y = <#=md.TypeCast#>((left.Z * right.X) - (left.X * right.Z));
                result.Z = <#=md.TypeCast#>((left.X * right.Y) - (left.Y * right.X));
        }

        /// <summary>
        /// Calculates the cross product of two <#=See(md.Name)#>.
        /// </summary>
        /// <param name="left">First source <#=See(md.Name)#>.</param>
        /// <param name="right">Second source <#=See(md.Name)#>.</param>

        public static <#=md.Name#> Cross(ref <#=md.Name#> left, ref <#=md.Name#> right)
        {
            return new <#=md.Name#>(
                <#=md.TypeCast#>((left.Y * right.Z) - (left.Z * right.Y)),
                <#=md.TypeCast#>((left.Z * right.X) - (left.X * right.Z)),
                <#=md.TypeCast#>((left.X * right.Y) - (left.Y * right.X)));
        }

        /// <summary>
        /// Calculates the cross product of two <#=See(md.Name)#>.
        /// </summary>
        /// <param name="left">First source <#=See(md.Name)#>.</param>
        /// <param name="right">Second source <#=See(md.Name)#>.</param>
        /// <returns>The cross product of the two <#=See(md.Name)#>.</returns>
        public static <#=md.Name#> Cross(<#=md.Name#> left, <#=md.Name#> right)
        {
            return Cross(ref left, ref right);
        }
#endregion
	}
}
<#
});
#>
