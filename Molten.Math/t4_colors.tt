<#@ template debug="false" hostspecific="true" language="C#" #>

<#@ include file="t4_header.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

<#
string[] vecPMapUpper = new string[]{"X", "Y", "Z", "W"};
TypeGenerator gen = new TypeGenerator(this.GenerationEnvironment, this.Host, "Colors", "def_colors.json");

gen.Generate(null, (d, def) =>
{
    string vectorName = $"Vector{d.Size}{d.DT.Literal}";
#>
using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Molten<#=d.SubNamespace#>
{
	/// <summary>
    /// Represents a color in the form of <#=gen.FieldsToArgs(def.FieldNames)#>.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    [Serializable]
    public struct <#=d.Name#> : IEquatable<<#=d.Name#>>, IFormattable
    {
        private const string toStringFormat = "Red:{0} Green:{1} Blue:{2}";

        /// <summary>
        /// The Black color (0, 0, 0).
        /// </summary>
        public static readonly <#=d.Name#> Black = new <#=d.Name#>(<#=d.DT.Zero#>);

        /// <summary>
        /// The White color (1, 1, 1, 1).
        /// </summary>
        public static readonly <#=d.Name#> White = new <#=d.Name#>(<#=d.DT.One#>);

<#=gen.GenerateFields()#>
<#gen.GenerateStandardConstructors();#>

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=d.Name#>"/> struct.
        /// </summary>
        /// <param name="value">The <#=gen.FieldsToArgs(def.FieldNames)#> components of the color.</param>
        public <#=d.Name#>(<#=vectorName#> value)
        {
<#for(int i = 0; i < d.Size; i++){#>
            <#=def.FieldNames[i]#> = value.<#=vecPMapUpper[i]#>;
<#}#>
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=d.Name#>"/> struct.
        /// </summary>
        /// <param name="rgb">A packed integer containing all three color components in RGB order.
        /// The alpha component is ignored.</param>
        public <#=d.Name#>(int rgb)
        {
            B = ((rgb >> 16) & 255) / 255.0<#=d.DT.Literal#>;
            G = ((rgb >> 8) & 255) / 255.0<#=d.DT.Literal#>;
            R = (rgb & 255) / 255.0<#=d.DT.Literal#>;
        }

        /// <summary>
        /// Gets or sets the component at the specified index.
        /// </summary>
        /// <value>The value of the red, green, or blue component, depending on the index.</value>
        /// <param name="index">The index of the component to access. Use 0 for the red component, 1 for the green component, and 2 for the blue component.</param>
        /// <returns>The value of the component at the specified index.</returns>
        /// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 2].</exception>
        public <#=d.DT#> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return R;
                    case 1: return G;
                    case 2: return B;
                }

                throw new ArgumentOutOfRangeException("index", "Indices for <#=d.Name#> run from 0 to 2, inclusive.");
            }

            set
            {
                switch (index)
                {
                    case 0: R = value; break;
                    case 1: G = value; break;
                    case 2: B = value; break;
                    default: throw new ArgumentOutOfRangeException("index", "Indices for <#=d.Name#> run from 0 to 2, inclusive.");
                }
            }
        }

        /// <summary>
        /// Converts the color into a packed integer.
        /// </summary>
        /// <returns>A packed integer containing all three color components.
        /// The alpha channel is set to 255.</returns>
        public int ToRgba()
        {
            uint a = 255;
            uint r = (uint) (R * 255.0<#=d.DT.Literal#>) & 255;
            uint g = (uint) (G * 255.0<#=d.DT.Literal#>) & 255;
            uint b = (uint) (B * 255.0<#=d.DT.Literal#>) & 255;

            uint value = r;
            value |= g << 8;
            value |= b << 16;
            value |= a << 24;

            return (int)value;
        }

        /// <summary>
        /// Converts the color into a packed integer.
        /// </summary>
        /// <returns>A packed integer containing all three color components.
        /// The alpha channel is set to 255.</returns>
        public int ToBgra()
        {
            uint a = 255;
            uint r = (uint)(R * 255.0<#=d.DT.Literal#>) & 255;
            uint g = (uint)(G * 255.0<#=d.DT.Literal#>) & 255;
            uint b = (uint)(B * 255.0<#=d.DT.Literal#>) & 255;

            uint value = b;
            value |= g << 8;
            value |= r << 16;
            value |= a << 24;

            return (int)value;
        }

        /// <summary>
        /// Converts the color into a three component vector.
        /// </summary>
        /// <returns>A three component vector containing the red, green, and blue components of the color.</returns>
        public <#=vectorName#> ToVector()
        {
            return new <#=vectorName#>(<#=gen.FieldsToArgs(def.FieldNames)#>);
        }

        /// <summary>
        /// Creates an array containing the elements of the color.
        /// </summary>
        /// <returns>A three-element array containing the components of the color.</returns>
        public <#=d.DT#>[] ToArray()
        {
            return new <#=d.DT#>[] { <#=gen.FieldsToArgs(def.FieldNames)#> };
        }

<#gen.GenerateRefOperator("+", "add");#>

<#gen.GenerateRefOperator("-", "subtract");#>

<#gen.GenerateRefOperator("*", "modulate");#>

<#gen.GenerateRefOperator("/", "divide");#>

        /// <summary>
        /// Scales a color.
        /// </summary>
        /// <param name="value">The color to scale.</param>
        /// <param name="scale">The amount by which to scale.</param>
        /// <param name="result">When the method completes, contains the scaled color.</param>
        public static void Scale(ref <#=d.Name#> value, <#=d.DT#> scale, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = value.{field} * scale;");#>
        }

        /// <summary>
        /// Scales a color.
        /// </summary>
        /// <param name="value">The color to scale.</param>
        /// <param name="scale">The amount by which to scale.</param>
        /// <returns>The scaled color.</returns>
        public static <#=d.Name#> Scale(<#=d.Name#> value, <#=d.DT#> scale)
        {
            return new <#=d.Name#>(value.R * scale, value.G * scale, value.B * scale);
        }

        /// <summary>
        /// Negates a color.
        /// </summary>
        /// <param name="value">The color to negate.</param>
        /// <param name="result">When the method completes, contains the negated color.</param>
        public static void Negate(ref <#=d.Name#> value, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = {d.DT.One} - value.{field};");#>
        }

        /// <summary>
        /// Negates a color.
        /// </summary>
        /// <param name="value">The color to negate.</param>
        /// <returns>The negated color.</returns>
        public static <#=d.Name#> Negate(<#=d.Name#> value)
        {
            return new <#=d.Name#>(<#=d.DT.One#> - value.R, <#=d.DT.One#> - value.G, <#=d.DT.One#> - value.B);
        }

        /// <summary>
        /// Restricts a value to be within a specified range.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The minimum value.</param>
        /// <param name="max">The maximum value.</param>
        /// <param name="result">When the method completes, contains the clamped value.</param>
        public static void Clamp(ref <#=d.Name#> value, ref <#=d.Name#> min, ref <#=d.Name#> max, out <#=d.Name#> result)
        {
<#
    for(int i = 0; i < d.Size; i++)
    {
        string n = def.FieldLabels[i];
        string p = def.FieldNames[i];
#>
            <#=d.DT#> <#=n#> = value.<#=p#>;
            <#=n#> = (<#=n#> > max.<#=p#>) ? max.<#=p#> : <#=n#>;
            <#=n#> = (<#=n#> < min.<#=p#>) ? min.<#=p#> : <#=n#>;

<#
    }
#>
            result = new <#=d.Name#>(<#=gen.FieldsToArgs(def.FieldLabels)#>);
        }

        /// <summary>
        /// Restricts a value to be within a specified range.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The minimum value.</param>
        /// <param name="max">The maximum value.</param>
        /// <returns>The clamped value.</returns>
        public static <#=d.Name#> Clamp(<#=d.Name#> value, <#=d.Name#> min, <#=d.Name#> max)
        {
            Clamp(ref value, ref min, ref max, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Performs a linear interpolation between two colors.
        /// </summary>
        /// <param name="start">Start color.</param>
        /// <param name="end">End color.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <param name="result">When the method completes, contains the linear interpolation of the two colors.</param>
        /// <remarks>
        /// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
        /// </remarks>
        public static void Lerp(ref <#=d.Name#> start, ref <#=d.Name#> end, <#=d.DT#> amount, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = MathHelper.Lerp(start.{field}, end.{field}, amount);");#>
        }

        /// <summary>
        /// Performs a linear interpolation between two colors.
        /// </summary>
        /// <param name="start">Start color.</param>
        /// <param name="end">End color.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <returns>The linear interpolation of the two colors.</returns>
        /// <remarks>
        /// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
        /// </remarks>
        public static <#=d.Name#> Lerp(<#=d.Name#> start, <#=d.Name#> end, <#=d.DT#> amount)
        {
            Lerp(ref start, ref end, amount, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Performs a cubic interpolation between two colors.
        /// </summary>
        /// <param name="start">Start color.</param>
        /// <param name="end">End color.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <param name="result">When the method completes, contains the cubic interpolation of the two colors.</param>
        public static void SmoothStep(ref <#=d.Name#> start, ref <#=d.Name#> end, <#=d.DT#> amount, out <#=d.Name#> result)
        {
            amount = MathHelper.SmoothStep(amount);
            Lerp(ref start, ref end, amount, out result);
        }

        /// <summary>
        /// Performs a cubic interpolation between two colors.
        /// </summary>
        /// <param name="start">Start color.</param>
        /// <param name="end">End color.</param>
        /// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
        /// <returns>The cubic interpolation of the two colors.</returns>
        public static <#=d.Name#> SmoothStep(<#=d.Name#> start, <#=d.Name#> end, <#=d.DT#> amount)
        {
            SmoothStep(ref start, ref end, amount, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Returns a color containing the smallest components of the specified colors.
        /// </summary>
        /// <param name="left">The first source color.</param>
        /// <param name="right">The second source color.</param>
        /// <param name="result">When the method completes, contains an new color composed of the largest components of the source colors.</param>
        public static void Max(ref <#=d.Name#> left, ref <#=d.Name#> right, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = (left.{field}  > right.{field} ) ? left.{field}  : right.{field} ;");#>
        }

        /// <summary>
        /// Returns a color containing the largest components of the specified colors.
        /// </summary>
        /// <param name="left">The first source color.</param>
        /// <param name="right">The second source color.</param>
        /// <returns>A color containing the largest components of the source colors.</returns>
        public static <#=d.Name#> Max(<#=d.Name#> left, <#=d.Name#> right)
        {
            Max(ref left, ref right, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Returns a color containing the smallest components of the specified colors.
        /// </summary>
        /// <param name="left">The first source color.</param>
        /// <param name="right">The second source color.</param>
        /// <param name="result">When the method completes, contains an new color composed of the smallest components of the source colors.</param>
        public static void Min(ref <#=d.Name#> left, ref <#=d.Name#> right, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = (left.{field} < right.{field}) ? left.{field} : right.{field};");#>
        }

        /// <summary>
        /// Returns a color containing the smallest components of the specified colors.
        /// </summary>
        /// <param name="left">The first source color.</param>
        /// <param name="right">The second source color.</param>
        /// <returns>A color containing the smallest components of the source colors.</returns>
        public static <#=d.Name#> Min(<#=d.Name#> left, <#=d.Name#> right)
        {
            Min(ref left, ref right, out <#=d.Name#> result);
            return result;
        }

        /// <summary>
        /// Adjusts the contrast of a color.
        /// </summary>
        /// <param name="value">The color whose contrast is to be adjusted.</param>
        /// <param name="contrast">The amount by which to adjust the contrast.</param>
        /// <param name="result">When the method completes, contains the adjusted color.</param>
        public static void AdjustContrast(ref <#=d.Name#> value, <#=d.DT#> contrast, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = 0.5{d.DT.Literal} + contrast * (value.{field} - 0.5{d.DT.Literal});");#>
        }

        /// <summary>
        /// Adjusts the contrast of a color.
        /// </summary>
        /// <param name="value">The color whose contrast is to be adjusted.</param>
        /// <param name="contrast">The amount by which to adjust the contrast.</param>
        /// <returns>The adjusted color.</returns>
        public static <#=d.Name#> AdjustContrast(<#=d.Name#> value, <#=d.DT#> contrast)
        {
            return new <#=d.Name#>(
                0.5<#=d.DT.Literal#> + contrast * (value.R - 0.5<#=d.DT.Literal#>),
                0.5<#=d.DT.Literal#> + contrast * (value.G - 0.5<#=d.DT.Literal#>),
                0.5<#=d.DT.Literal#> + contrast * (value.B - 0.5<#=d.DT.Literal#>));
        }

        /// <summary>
        /// Adjusts the saturation of a color.
        /// </summary>
        /// <param name="value">The color whose saturation is to be adjusted.</param>
        /// <param name="saturation">The amount by which to adjust the saturation.</param>
        /// <param name="result">When the method completes, contains the adjusted color.</param>
        public static void AdjustSaturation(ref <#=d.Name#> value, <#=d.DT#> saturation, out <#=d.Name#> result)
        {
            <#=d.DT#> grey = value.R * 0.2125f + value.G * 0.7154f + value.B * 0.0721f;
<#gen.IterateFields((i, field) => $"result.{field} = grey + saturation * (value.{field}  - grey);");#>
        }

        /// <summary>
        /// Adjusts the saturation of a color.
        /// </summary>
        /// <param name="value">The color whose saturation is to be adjusted.</param>
        /// <param name="saturation">The amount by which to adjust the saturation.</param>
        /// <returns>The adjusted color.</returns>
        public static <#=d.Name#> AdjustSaturation(<#=d.Name#> value, <#=d.DT#> saturation)
        {
            <#=d.DT#> grey = value.R * 0.2125f + value.G * 0.7154f + value.B * 0.0721f;

            return new <#=d.Name#>(
                grey + saturation * (value.R - grey),
                grey + saturation * (value.G - grey),
                grey + saturation * (value.B - grey));
        }

        /// <summary>
        /// Computes the premultiplied value of the provided color.
        /// </summary>
        /// <param name="value">The non-premultiplied value.</param>
        /// <param name="alpha">The color alpha.</param>
        /// <param name="result">The premultiplied result.</param>
        public static void Premultiply(ref <#=d.Name#> value, <#=d.DT#> alpha, out <#=d.Name#> result)
        {
<#gen.IterateFields((i, field) => $"result.{field} = value.{field} * alpha;");#>
        }

        /// <summary>
        /// Computes the premultiplied value of the provided color.
        /// </summary>
        /// <param name="value">The non-premultiplied value.</param>
        /// <param name="alpha">The color alpha.</param>
        /// <returns>The premultiplied color.</returns>
        public static <#=d.Name#> Premultiply(<#=d.Name#> value, <#=d.DT#> alpha)
        {
            Premultiply(ref value, alpha, out <#=d.Name#> result);
            return result;
        }

<#gen.GenerateOperator("+", "Add");#>

        /// <summary>
        /// Assert a color (return it unchanged).
        /// </summary>
        /// <param name="value">The color to assert (unchanged).</param>
        /// <returns>The asserted (unchanged) color.</returns>
        public static <#=d.Name#> operator +(<#=d.Name#> value)
        {
            return value;
        }

<#gen.GenerateOperator("-", "subtract");#>

        /// <summary>
        /// Negates a color.
        /// </summary>
        /// <param name="value">The color to negate.</param>
        /// <returns>A negated color.</returns>
        public static <#=d.Name#> operator -(<#=d.Name#> value)
        {
            return new <#=d.Name#>(<#=gen.FieldsToArgs(def.FieldNames, "-value")#>);
        }

        /// <summary>
        /// Scales a color.
        /// </summary>
        /// <param name="scale">The factor by which to scale the color.</param>
        /// <param name="value">The color to scale.</param>
        /// <returns>The scaled color.</returns>
        public static <#=d.Name#> operator *(<#=d.DT#> scale, <#=d.Name#> value)
        {
            return new <#=d.Name#>(value.R * scale, value.G * scale, value.B * scale);
        }

        /// <summary>
        /// Scales a color.
        /// </summary>
        /// <param name="value">The factor by which to scale the color.</param>
        /// <param name="scale">The color to scale.</param>
        /// <returns>The scaled color.</returns>
        public static <#=d.Name#> operator *(<#=d.Name#> value, <#=d.DT#> scale)
        {
            return new <#=d.Name#>(value.R * scale, value.G * scale, value.B * scale);
        }

<#gen.GenerateOperator("*", "modulate");#>

<#gen.GenerateOperator("/", "divide");#>

        /// <summary>
        /// Tests for equality between two objects.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#=d.Name#> left, <#=d.Name#> right)
        {
            return left.Equals(ref right);
        }

        /// <summary>
        /// Tests for inequality between two objects.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#=d.Name#> left, <#=d.Name#> right)
        {
            return !left.Equals(ref right);
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="<#=d.Name#>"/> to <see cref="Color4"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator Color4(<#=d.Name#> value)
        {
            return new Color4(value.R, value.G, value.B, <#=d.DT.One#>);
        }

        /// <summary>
        /// Performs an implicit conversion from <see cref="<#=d.Name#>"/> to <see cref="Vector3F"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator <#=vectorName#>(<#=d.Name#> value)
        {
            return new <#=vectorName#>(<#=gen.FieldsToArgs(def.FieldNames, "value")#>);
        }

        /// <summary>
        /// Performs an implicit conversion from <see cref="Vector3F"/> to <see cref="<#=d.Name#>"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator <#=d.Name#>(Vector3F value)
        {
            return new <#=d.Name#>(value.X, value.Y, value.Z);
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="System.Int32"/> to <see cref="<#=d.Name#>"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>The result of the conversion.</returns>
        public static explicit operator <#=d.Name#>(int value)
        {
            return new <#=d.Name#>(value);
        }

        /// <summary>
        /// Returns a <see cref="string"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="string"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return ToString(CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// Returns a <see cref="string"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format to apply to each channel element (<#=d.DT#>)</param>
        /// <returns>
        /// A <see cref="string"/> that represents this instance.
        /// </returns>
        public string ToString(string format)
        {
            return ToString(format, CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// Returns a <see cref="string"/> that represents this instance.
        /// </summary>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="string"/> that represents this instance.
        /// </returns>
        public string ToString(IFormatProvider formatProvider)
        {
            return string.Format(formatProvider, toStringFormat, R, G, B);
        }

        /// <summary>
        /// Returns a <see cref="string"/> that represents this instance.
        /// </summary>
        /// <param name="format">The format to apply to each channel element (<#=d.DT#>).</param>
        /// <param name="formatProvider">The format provider.</param>
        /// <returns>
        /// A <see cref="string"/> that represents this instance.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
                return ToString(formatProvider);

            return string.Format(formatProvider,
                                 toStringFormat,
                                 R.ToString(format, formatProvider),
                                 G.ToString(format, formatProvider),
                                 B.ToString(format, formatProvider));
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
        /// </returns>
        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R.GetHashCode();
                hashCode = (hashCode * 397) ^ G.GetHashCode();
                hashCode = (hashCode * 397) ^ B.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// Determines whether the specified <see cref="<#=d.Name#>"/> is equal to this instance.
        /// </summary>
        /// <param name="other">The <see cref="<#=d.Name#>"/> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <see cref="<#=d.Name#>"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(ref <#=d.Name#> other)
        {
            return R == other.R && G == other.G && B == other.B;
        }

        /// <summary>
        /// Determines whether the specified <see cref="<#=d.Name#>"/> is equal to this instance.
        /// </summary>
        /// <param name="other">The <see cref="<#=d.Name#>"/> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <see cref="<#=d.Name#>"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=d.Name#> other)
        {
            return Equals(ref other);
        }

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="value">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        /// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object value)
        {
            if (!(value is <#=d.Name#>))
                return false;

            var strongValue = (<#=d.Name#>)value;
            return Equals(ref strongValue);
        }


        /// <summary>
        /// Returns a new <see cref="<#=d.Name#>"/> with the values of the provided color's components assigned based on their index.<para/>
        /// For example, a swizzle input of (2,2,3) on a <see cref="<#=d.Name#>"/> with RGBA values of 100,20,255, will return a <see cref="Color4"/> with values 20,20,255.
        /// </summary>
        /// <param name="col">The color to use as a source for values.</param>
        /// <param name="rIndex">The axis index of the source color to use for the new red value.</param>
        /// <param name="gIndex">The axis index of the source color to use for the new green value.</param>
        /// <param name="bIndex">The axis index of the source color to use for the new blue value.</param>
        /// <returns></returns>
        public static unsafe <#=d.Name#> Swizzle(Color4 col, int rIndex, int gIndex, int bIndex)
        {
            return new <#=d.Name#>()
            {
                R = *(&col.R + (rIndex * sizeof(int))),
                G = *(&col.G + (gIndex * sizeof(int))),
                B = *(&col.B + (bIndex * sizeof(int))),
            };
        }
    }
}
<#
});
#>